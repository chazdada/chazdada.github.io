<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySQL技术内幕（一）]]></title>
    <url>%2F2019%2F10%2F30%2FMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[MySQL技术内幕（一）数据库：物理操作系统文件或其他类型文件集合 如果表格b采用MyISAM，在数据库/usr/local/mysql/data/user 中会产生3个文件： b.frm ：描述表结构文件，字段长度等 b.MYD(MYData)：数据信息文件，存储数据信息(如果采用独立表存储模式) b.MYI(MYIndex)：索引信息文件。 如果表格b采用InnoDB，在数据库/usr/local/mysql/data/user中会产生1个或者2个文件： b.frm ：描述表结构文件，字段长度等 如果采用独立表存储模式，/usr/local/mysql/data/user中还会产生b.ibd文件（存储数据信息和索引信息） 如果采用共存储模式的，数据信息和索引信息都存储在ibdata1中 数据库实例：有数据库后台进程/线程以及一个共享内存区组成，数据库实例用来操作数据库文件 MySQL设计为单进程多线程架构。 启动实例时，MySQL会读取配置文件，根据配置文件启动数据库。没有配置文件不会报错，根据默认参数，而Oracle会。 MySQL由以下几部分组成： 连接池组件 管理服务和工具组件 SQL接口组件 查询分析器组件 优化器组件 缓冲组件 插件式存储引擎 物理文件 存储引擎是基于表的。 InnoDB 存储引擎InnoDB 体系架构 内存池 缓存池：缓存各种数据，将数据库文件按页读到缓冲池，按最近最少使用算法保留缓冲池中的数据。数据库文件修改，先修改缓存池的页，再按一定频率将脏页刷新到文件。 缓存数据类型： 索引页 数据页 undo页（ https://blog.csdn.net/alexdamiao/article/details/51872477 ） 插入缓存 自适应哈希索引 锁信息 数据字典信息 重做日志缓冲池：重做日志信息 额外内存池：一些数据结构分配内存需要从该区申请 后台线程：负责刷新内存池中的数据，保证缓冲池中的内存缓存的是最近的数据。将已修改的数据文件刷新到磁盘，同时在异常情况下恢复 后台线程7个：4个IO线程，1个master线程，1个锁线程，1个错误监控线程 关键特性 插入缓冲（性能） 对于非聚集的辅助索引，数据页的存放还是按主键id的执行顺序存放。对于非聚集索引，叶子节点的插入不是顺序的。先判断插入的非聚集索引页是否在缓冲池里，如果在，直接插入。不在先放入插入缓冲区中，再按一定的频率执行插入缓冲和非聚集索引的叶子节点进行合并操作。 前提条件： 索引是辅助索引 索引不是唯一的（原因：如果唯一，又需要查找索引页的情况，出现离散读的情况，插入缓冲失去了意义） 两次写（可靠性） 内存 doublewrite buffer 物理磁盘上共享表空间 脏页刷新时，先将脏页拷贝到内存doublewrite buffer，然后每次写1mb到共享表空间，马上同步磁盘 自适应哈希 InnoDB监控对表上索引的查找，如果观察到建立哈希索引可以加速，则建立。通过缓冲池的B+树构造，按频率为页建立，不需要将整个表都建哈希索引。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库（三）]]></title>
    <url>%2F2019%2F10%2F25%2F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SQLSQL数据定义基本类型 char(n) 固定长度，字符长度不够，后面追加空格 varchar(n) 可变长度 int numeric(p,d) p个数，小数点后为d位 float(n) n为精度 基本模式定义 creat 主键 外键 完整性约束 SQL查询单关系查询多关系查询]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>DBMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java文件]]></title>
    <url>%2F2019%2F10%2F06%2Fjava%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[Java 文件路径 文件位于项目根目录下 1InputStream in = new BufferedInputStream(new FileInputStream("src/main/resources/test.properties")); 文件位于类路径下，可利用Class对象或者ClassLoader对象去在类路径下查找文件 12InputStream in = p.getClass().getResourceAsStream("/test.properties");InputStream in = p.getClass().getClassLoader().getResourceAsStream("test.properties"); 注意： Class对象的getResourceAsStream(String path)中的path可以以 / 开头，也可以不以 / 开头。若以 / 开头，表示在类路径根目录下查找，不以 / 开头，表示在当前.java文件编译后.class文件所在的目录中找 ClassLoader对象的getResourceAsStream(String path)中的path不以/开头！，表示在类路径根目录下查找]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[post_name]]></title>
    <url>%2F2019%2F10%2F05%2Fpost-name%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[数据库（二）]]></title>
    <url>%2F2019%2F10%2F05%2F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据库（二）关系数据库关系数据的结构由表的集合构成，表中的一行代表一组值之间的联系。表与关系这个概念紧密相连。 n个值之间的联系可以用n-元组表示，对应于表中的一行。 关系&lt;–&gt;表 元组&lt;–&gt;行 属性&lt;–&gt;列 域：关系每个属性允许取值的集合，域要求是原子的 空值（null） 数据库模式数据库模式：数据库逻辑设计 数据库实例：数据库数据的快照 关系模式：类似于类型定义 关系实例：类似于变量的值 码（key）超码（superkey）：这些属性的组合可以使我们在一个关系中唯一的标识一个元组。 候选码（candidatekey）：超码的最小子集 主码（primary key）：由数据库表设计者选中的，用于主要区分不同元组的候选码 主码应该选择那些值从不和极少发生变化的属性 外码（foreign key）：一个关系（r1）模式可能在他的属性中包括另一个关系（r2）的主码。r1也被称为外码依赖的参照关系，r2外码的被参照关系。 关系查询语言 过程化语言 用户指导系统对数据库进行一系列操作以计算出所需的结果 非过程化语言 用户只需要描述出所需的信息，而不用给出具体过程 关系运算]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>DBMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库（一）]]></title>
    <url>%2F2019%2F10%2F04%2F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据库（一）数据库概念文件处理系统弊端： 数据的冗余和不一致 数据访问困难 数据孤立 完整性问题（约束） 原子性问题（例如转账操作） 并发访问异常 安全性问题 数据库系统 = 数据 + 修改数据的程序 数据视图抽象视图：隐藏数据存储和维护的细节 数据抽象 物理层：详细描述底层复杂结构 逻辑层 视图层 实例和模式实例：存储在数据库信息的集合 模式：数据库的总体设计 物理模式 逻辑模式 子模式 数据模型数据模型是一种描述数据、数据联系、数据语义以及一致性约束的概念工具的集合。数据模型提供了一种描述物理层、逻辑层以及视图层数据库设计的方式。 关系模型 E-R模型 基于对象的数据模型 半结构化数据模型 数据库语言 数据操纵语言（DML） 增删改查 数据定义语言（DDL） 数据存储与定义 域约束 参照完整性 断言 授权 DDL的输出放入数据字典中，数据字典包含了元数据。 数据存储与查询数据库系统的功能部件大致可以分为存储管理器和查询处理部件 存储管理器：与操作系统文件系统交互 权限及完整性管理器：完整性约束，用户权限 事务管理器：事务的执行 文件管理器：磁盘存储与分配 缓冲区管理器：决定哪些数据从磁盘上转移到内存缓冲区中 实现的数据结构： 数据文件：数据库本身 数据字典：数据库模式，元数据：数据的数据 索引 查询处理器 DDL解释器：解释DDL语句并记录在数据字典 DML编译器：翻译成执行方案，产生低级指令 查询执行引擎：执行低级指令 事务管理 一致性 原子性 持久性 事务：数据库应用中完成单一逻辑功能的操作集合 事务管理器： 并发控制管理器 恢复管理器]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>DBMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis源码分析（一）]]></title>
    <url>%2F2019%2F10%2F02%2FMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Mybatis 源码分析（一）参考：一本小小的MyBatis源码分析书 Mybatis 入门Mybatis 是什么？ MyBatis 是一种半自动化的 Java 持久层框架（persistence framework），其通过注解或 XML的方式将对象和 SQL 关联起来。半自动是因为和 Hibernate 等一些可自动生成SQL的ORM(Object Relational Mapping)框架相比，使用MyBatis需要用户自行维护SQL。 与 JDBC 对比jdbc 缺点: 代码繁琐，冗余 拼接 SQL 可能会导致 SQL 出错 SQL 写在代码中，如果要改动 SQL，就需要到代码中进行更改 手动从 ResultSet中取出数据 用户需要自行处理受检异常 Mybatis: SqlSessionFactory 是一个工厂类，一旦被创建就应该在应用运行期间一直存在，不应该丢弃或重建。SqlSession 不是线程安全的，所以不应被多线程共享。官方推荐的使用方式是有按需创建，用完即销毁。 使用 MyBatis 无需处理受检异常 SQL 写在配置文件中，进行集中管理，利于维护。同时将 SQL 从代码中剥离，在提高代码的可读性的同时，也避免了拼接 SQL 可能会导致的错误 将查询结果映射为相应的对象 JDBC 可看做是一种基础服务，MyBatis 则是构建在基础服务之上的框架。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM（二）]]></title>
    <url>%2F2019%2F09%2F25%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[深入理解 JVM（二）编译：创建完源文件之后，程序先要被JVM中的java编译器进行编译为.class文件。java编译一个类时，若这个类所依赖的类还没有被编译，编译器会自动的先编译这个所依赖的类，然后引用；若java编译器在指定的目录下找不到该类所依赖的类的 .class文件或者 .java源文件，就会报”Can’t found sysbol”的异常错误。 编译后的字节码文件格式主要分为两部分：常量池和方法字节码。 类加载与常量常量在编译阶段会存入到调用这个常量的方法所在的类的常量池中。 本质上，调用类并没有直接引用到定义常量的类，因此并不会触发定义常量的类的初始化。 当一个常量的值并非编译期间可以确定的，那么其值就不会被放到调用类的常量池中，当这程序在运行时，会导致主动使用这个常量所在的类，显然会导致这个类的初始化。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap知识点]]></title>
    <url>%2F2019%2F09%2F19%2FHashMap%2F</url>
    <content type="text"><![CDATA[HashMapHashMap 定义HashMap是基于哈希表实现的，每一个元素是一个key-value对，其内部通过数组和单链表实现。 HashMap 工作原理HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。 put() 方法实现步骤 对Key求Hash值，然后再计算下标 如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的Hash值相同，需要放到同一个bucket中） 如果碰撞了，以链表的方式链接到后面 如果链表长度超过阀值( TREEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于6，就把红黑树转回链表 如果节点已经存在就替换旧值 如果桶（数组）满了(容量16*加载因子0.75)，就需要 resize（扩容2倍后重排） get() 方法 HashMap会使用键对象的hashcode找到bucket位置，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。 hash 函数如何计算hash函数作用：根据hashcode() 求出其对应数组下标的位置 原理： 高16bit不变，低16bit和高16bit做了一个异或 (n·1)&amp;hash jdk1.8 源码： 1234567891011static final int hash(Object key) &#123; if (key == null)&#123; return 0; &#125; int h; h=key.hashCode()；返回散列值也就是hashcode // ^ ：按位异或 // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐 //其中n是数组的长度，即Map的数组部分初始化长度 return (n-1)&amp;(h ^ (h &gt;&gt;&gt; 16));&#125; 红黑树红黑树的性质 每个节点非红即黑 根节点总是黑色的 如果节点是红色的，则它的子节点必须是黑色的（反之不一定） 每个叶子节点都是黑色的空节点（NIL节点） 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度） 为什么选择使用红黑树二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。 HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。这个值只可能在两个地方，一个是原下标的位置，另一种是在下标为&lt;原下标+原容量&gt;的位置。 解决冲突其他办法 开放定址法 线性探查法 二次探查法 双重散列法 HashTable 数组 + 链表方式存储 默认容量：11(质数为宜) 索引计算 : （key.hashCode() &amp; 0x7FFFFFFF）% table.length 若在链表中找到了，则替换旧值，若未找到则继续 当总元素个数超过容量*加载因子时，扩容为原来 2 倍并重新散列。 将新元素加到链表头部 对修改 Hashtable 内部共享数据的方法添加了 synchronized，保证线程安全。 HashMap 与 HashTable 的区别 Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类。但二者都实现了Map接口。 HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey。Hashtable则保留了contains，containsValue和containsKey三个方法，其中contains和containsValue功能相同。 默认容量不同，扩容不同。计算索引方式不同。 线程安全性，HashTable 安全 效率不同 HashTable 要慢因为加锁 hashmap 键值可以设置为空值，hashtable 不可以。hashmap 将null存到table[0]中去了。 ConcurrentHashMap 原理CocurrentHashMap 与 Hashtable 加锁方式对比Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。它们都可以用于多线程的环境，但是当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。因为ConcurrentHashMap引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需要等到迭代完成才能访问map。简而言之，在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM（一）]]></title>
    <url>%2F2019%2F08%2F30%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[深入理解 JVM课程参考：http://www.iprogramming.cn 类加载Java 中类型的加载、连接和初始化过程都是在程序运行期间完成。 类型：类本身而不是实例化的对象。 加载：类的class文件从磁盘加载到内存中。 将.class文件中的二进制数据读入到内存中，放入运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象，用来封装在方法区内的数据结构。 连接：将类与类之间的关系确定好，检验字节码文件。 验证：类的正确性。 准备：类的静态变量分配内存，初始化为默认值。 解析：类中符号引用转为直接引用。 初始化：类的静态变量赋予正确的初始值，首次主动使用。 类加载器作用：将类加载到内存。 类的使用与卸载 使用 卸载 类的使用方式 主动使用 创建类的实例 访问某个类或接口静态变量或赋值 调用类的静态方法 反射 初始化一个类的子类 启动类的类 动态语言的支持 被动使用 不会导致类的初始化 1234567891011121314151617181920public class MyTest1 &#123; public static void main(String[] args) &#123; System.out.println(Child.str1); &#125;&#125;class Parent&#123; static String str1 = "123"; static &#123; System.out.println("Parent static block"); &#125;&#125;class Child extends Parent&#123; static String str2 = "234"; static &#123; System.out.println("child static block"); &#125;&#125; 结果 12Parent static block123 分析 对于静态字段来说，只有直接定义了该字段的类才会被初始化 1234567891011121314151617181920public class MyTest1 &#123; public static void main(String[] args) &#123; System.out.println(Child.str2); &#125;&#125;class Parent&#123; static String str1 = "123"; static &#123; System.out.println("Parent static block"); &#125;&#125;class Child extends Parent&#123; static String str2 = "234"; static &#123; System.out.println("child static block"); &#125;&#125; 结果 123Parent static blockchild static block234 分析 当一个类初始化时，要求其父类全部初始化完毕。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Java多线程操作（一）]]></title>
    <url>%2F2019%2F08%2F24%2Fthread%2F</url>
    <content type="text"><![CDATA[线程线程基本概念线程是 CPU 调度的基本单位，进程是 CPU 分配资源的基本单位。 Java 中的多线程Java 中创建多线程的两种方式 通过继承Thread类，并重写run方法创建线程 1234567class MyThread extends Thread&#123; @Override public void run() &#123; System.out.println("hello thread!"); &#125;&#125; 通过实现Runnable接口，并传递给Thread类，创建线程。 1234567class MyThread2 implements Runnable&#123; @Override public void run() &#123; System.out.println("hello thread2!"); &#125;&#125; Java 中的线程生命周期 线程新建状态 使用 Java 创建线程的两种方法，创建一个新的线程。 线程就绪状态 通过调用新线程的start()方法使之进入就绪状态 运行中的线程失去CPU运行时间进入就绪状态 阻塞状态的线程处理完阻塞进入就绪状态 线程运行状态 就绪状态的线程一旦获得CPU便进入运行状态 线程阻塞状态 使用线程的sleep()方法 运行状态中的线程执行wait()方法 线程死亡状态 线程生命周期结束 Java 线程同步Java 多个线程同时抢夺资源，造成冲突问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Bank&#123; int i = 0; void add()&#123; i++; &#125; int getI()&#123; return i; &#125;&#125;class MyThread extends Thread&#123; Bank bank; MyThread(Bank b)&#123; bank = b; &#125; @Override public void run() &#123; for(int x = 0; x &lt; 10; x++) &#123; bank.add(); System.out.println(Thread.currentThread().getName() + " value: " +bank.getI()); &#125; &#125; &#125;public class Demo &#123; public static void main(String[] args) &#123; Bank bank = new Bank(); MyThread myThread = new MyThread(bank); myThread.start(); MyThread myThread2 = new MyThread(bank); myThread2.start(); MyThread myThread3 = new MyThread(bank); myThread3.start(); &#125;&#125; 运行结果： 12345Thread-0 value: 2Thread-0 value: 4Thread-2 value: 3Thread-1 value: 2Thread-2 value: 6 同步方法 使用synchronized关键字 由于 Java 的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。 123public synchronized void add()&#123; i++; &#125; 同步代码块 有synchronized关键字修饰的语句块，被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。必须使用同一个锁。 12345public void add()&#123; synchronized (this) &#123; i++; &#125; &#125; 使用特殊域变量(volatile)实现线程同步 volatile具有synchronized关键字的“可见性”，但是没有synchronized关键字的“并发正确性”，也就是说不保证线程执行的有序性。 volatile变量对于每次使用，线程都能得到当前volatile变量的最新值。但是volatile变量并不保证并发的正确性。 1volatile int i = 0; https://www.hollischuang.com/archives/2648 使用重入锁（Lock）实现线程同步 123ReentrantLock() : 创建一个ReentrantLock实例 lock() : 获得锁 unlock() : 释放锁 123456789class Bank&#123; volatile int i = 0; private Lock lock = new ReentrantLock(); void add()&#123; lock.lock(); i++; lock.unlock(); &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[你真的了解HTTP吗？(一)]]></title>
    <url>%2F2020%2F07%2F10%2FHttp(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[你真的了解HTTP 吗？(一)要学 HTTP ，先来推荐一个学习网站： HTTP 是什么？协议格式是怎样的？等这些基础问题，这里就不介绍了。MDN 以及好多博客都介绍的挺全的。这篇文章主要介绍一下HTTP 的连接管理（短连接, 长连接, 和 HTTP 流水线）。 短连接HTTP协议被广泛应用于浏览器和服务器架构模式之下。HTTP协议是位于应用层的一种协议，其所使用的传输层协议是TCP协议。TCP是一种可靠传输的协议，浏览器与服务器建立连接过程会经历三次握手过程。 HTTP 最早期的模型，也是 HTTP/1.0 的默认模型，是短连接。每一个 HTTP 请求都由它自己独立的连接完成；这意味着发起每一个 HTTP 请求之前都会有一次 TCP 握手，而且是连续不断的。 通俗一点的话说就是：我浏览器每次访问一个 URL，浏览器会与服务器建立一个 TCP 连接。浏览器发送完请求然后等待服务返回一个响应。当这一个回合的过程结束后，服务器会断开 TCP 连接。所以浏览器就会知道服务器与我断开连接了，请求结束了。最后浏览器开始渲染页面等工作。 不用多说，一眼就能看出这种模式的坏处。每请求一次都要重新建立连接，即使一个浏览器都要这样，太麻烦了。ps:三次握手都握麻了。所以怎么办呢？HTTP 1.1 支持长连接模型协议出世了。 长连接HTTP 1.1 使用长连接方式很简单，只要在请求（request） 头部添加connection:keep-alive就OK了。 在长连接这种方式下，浏览器与服务器建立TCP连接后，不立即断开，而是等待一会看看还有没有别的请求。浏览器会先发送一个请求等待响应，当接收到响应后，再发送另一个请求，等待响应，直到所有请求响应发送接收完毕。 在这一过程中为了保证浏览器和服务器 TCP连接不断开，会有心跳检测机制。服务器在一段时间没有接收到该连接请求后，也会自动断开，回收资源。 但是可以发现一个问题是：在这种回合制的模式下，服务器发给浏览器响应，浏览器怎么知道服务发没发送完呢？ 两种方式： 对于静态的资源，可以提前知道大小的，我们响应头可以使用content-length:124字段。很明显我们就知道了响应消息体的大小。 对于那些动态资源呢？比如传输大量数据，为了整个系统效率，我们不可能把所有资源准备完毕，测出大小来再发送吧。所以有了Transfer-Encoding:chunked响应头字段。数据以一系列分块的形式进行发送。 Content-Length 首部在这种情况下不被发送，发送也会失效。其格式如下： 123456789101112HTTP/1.1 200 OK Content-Type: text/plain Transfer-Encoding: chunked7\r\nMozilla\r\n 9\r\nDeveloper\r\n7\r\nNetwork\r\n0\r\n \r\n 当收到0\r\n \r\n块时，浏览器就知道了这次响应结束了。 几个开胃小实验Transfer-Encoding 和 Content-Encoding对比： Content-Encoding 表示消息体已经采用了的编码方式，比如gzip压缩。 Content-Encoding是”端到端”. Transfer-Encoding 是一个逐跳传输消息首部，即仅应用于两个节点之间的消息传递，而不是所请求的资源本身。一个多节点连接中的每一段都可以应用不同的Transfer-Encoding 值。 理解一个用于传输报文，是两点之间的，一个是对content内容实际进行的编码。 Transfer-Encoding值得注意是给字段可以对应许多值，比如： 12345Transfer-Encoding: chunkedTransfer-Encoding: compressTransfer-Encoding: deflateTransfer-Encoding: gzipTransfer-Encoding: identity 在长连接下，除了Transfer-Encoding: identity，其他都会使用分块传输的方式，确定响应大小。 第一个有趣的实验，当 Nginx 使用 gzip 压缩，然后关闭分块的方式，服务器如何判断大小呢？结果：服务器响应完请求后会close，如此浏览器便知道响应结束了。显然，变化为HTTP 1.0 的方式。 第二个有趣的实验，当 Nginx 关闭 gzip 压缩，服务器如何判断大小呢？结果：服务器响应头中包含content-length字段。 第三个有趣的实验，springboot 长连接响应头是什么样的？结果：分块模式 123456HTTP/1.1 200Content-Type: application/jsonTransfer-Encoding: chunkedDate: Fri, 10 Jul 2020 09:30:56 GMTKeep-Alive: timeout=60Connection: keep-alive Note: HTTP 流水线 和 HTTP 2.0 等后续介绍]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL权限体系]]></title>
    <url>%2F2020%2F06%2F08%2Fmysql%E6%9D%83%E9%99%90%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[MySQL权限体系MySQL数据库的权限验证相比于Oracle中间添加了一层，及host（从哪里来）。例如：从丙处来的那个甲拥有访问已的权限。 处理逻辑MySQL数据库服务采用的是白名单的权限策略。 能不能连接MySQL首先检查登录用户相关信息，如登录主机名是否匹配，用户名和密码是否正确。这三项对应mysql user表中的user、password和host三列，可以为空“”（不是null）。 能不能执行操作涉及的表： mysql.user mysql.db mysql.tables_priv mysql.columns_priv mysql.proc_priv MySQL服务按照粒度从粗到细的方式。 权限变更失效 通过grant、revoke、set password、rename user，权限马上生效，将触发系统重新载入授权表到内存 手动修改字典表的方式，并不会马上生效 授权表被重新加载后，对当前连接的客户端影响： 表或列粒度将在客户端下次执行操作时 数据库级将在客户端执行use db_name 全局权限和密码修改，下次连接时生效 权限授予与收回创建用户 1234567creat user jss;set password for jss=password(&quot;abc&quot;);设置密码过期，仍可登录，无法进行操作alter user jss password expire;grant select on jssdb.* to jss@&quot;192.168.6.33&quot; identified by &quot;abc&quot;; MySQL用户和主机（”user”@”host”）组成一个唯一账户，并通过该账户进行验证。 mysql启动时会将user表加入内存，会进行排序，按照明确不明确。 手动修改权限字典后，要执行flush privilege语句，重新加载授权信息到内存。 12345grant select on mysql.user to jss_grant@&quot;192.168.6.33&quot;;show grants for jss_grant@&quot;192.168.6.33&quot;；收回权限revoke select on mysql.user from jss_grant@&quot;192.168.6.33&quot;; MySQL数据库中的权限，操作时授予和收回的权限级别必须对应，否则无法成功收回。 12清楚一个用户所有权限revoke all privileges，grant option from user; 删除用户 1drop user user_name; MySQL与oracle不同，MySQL数据库中的对象保存并不是依赖于用户，而依赖库。 权限级别全局 mysql.user 所有数据库的[所有]对象的[所有]权限 grant create *.* to jss_global; 数据库 数据库下[所有]对象的[所有]权限，mysql.db grant create jssdb.* to jss_global; 表 mysql.tables_priv字典表中 列 mysql.columns_priv grant select(col_name) on jssdb.users to jss_global; 账户安全管理 在尽可能不增加应用端开发工作量的前提下，尽可能缩小权限分配粒度 业务级账户分离 操作者在执行sql时所使用的账户与其能够执行操作相对应。 notes： mysql命令行工具执行的所有操作，会被记录到 .mysql_history文件中 1234解决方式1.修改系统层MYSQL_HISTFILE环境变量，改为/dev/null或者2.仍然保留 .mysql_history 文件实际为/dev/null的软链接]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL库与表]]></title>
    <url>%2F2020%2F06%2F07%2Fmysql%E5%BA%93%E4%B8%8E%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[MySQL库与表数据库mysql数据库（物理概念）像是Oracle中表空间（逻辑概念），mysql数据库中的库跟Oracle数据库中的数据库完全不同。前者数据库是由多个数据库组成，而oracle数据库是一个整体。mysql数据库中的库像是Oracle数据库中的schema（某个用户的模式）。mysql中的schema就是数据库的同义词。 mysql默认四个库 information_schema：记录用户、表、视图等元数据信息，类似于数据字典 mysql：记录用户权限、帮助、日志等信息 performance_schema：mysql服务性能指标库 test：测试库 12show databases; :显示当前连接用户拥有访问权限的数据库drop database [if exists] db_name; 可以在data目录下直接创建文件夹，即可创建数据库。 系统使用sql创建数据库时，默认db.opt内容,不指定的情况下，使用系统变量。 12default-character-set=utf8 #字符集default-collation=utf8_general_ci #校对规则 查看数据库字符集命令： 12show create database db_name;select * from information_schema.schemata; 表用户操作的数据必然保存在某个数据库中的表对象。 12desc tablename; 查看表结构信息show index from mysql.db; 查看索引信息 查看表对象创建脚本 1show create table mysql.db; 修改表结构 123alter table table_name add (col col_deinition);alter table table_name drop col_name;alter table table_name change col_name new_col col_definiton; note: mysql中：varchar和char指定的是字符长度而不是字节长度。 innodb引擎的表对象，每次执行结构的变更都相当于整表的重建。 删除表 对于myisam 存储引擎的表对象，完全可以通过删除操作系统层物理文件的方式删除表 innodb：表对象分为共享表空间方式存储和独立表空间，前者无法通过直接删除的方式 移动表 1rename table tb1_name to new_tb1_name;]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识 JVM]]></title>
    <url>%2F2020%2F03%2F30%2Fjvm1%2F</url>
    <content type="text"><![CDATA[初识 JVM为什么需要 jvmJava 作为一门高级程序语言，它的语法非常复杂，抽象程度也很高。因此，直接在硬件上运行这种复杂的程序并不现实。设计一个面向 Java 语言特性的虚拟机，并通过编译器将 Java 程序转换成该虚拟机所能识别的指令序列，也称 Java 字节码。java 虚拟机可以由硬件实现，但更为常见的是在各个现有平台（如 Windows_x64、Linux_arch64）上提供软件实现。这么做的意义在于，一旦一个程序被转换成 Java 字节码，那么它便可以在不同平台上的虚拟机实现里运行。 虚拟机的另外一个好处是它带来了一个托管环境（Managed Runtime）。这个托管环境能够代替我们处理一些代码中冗长而且容易出错的部分。其中最广为人知的当属自动内存管理与垃圾回收，这部分内容甚至催生了一波垃圾回收调优的业务。除此之外，托管环境还提供了诸如数组越界、动态类型、安全权限等等的动态检测，使我们免于书写这些无关业务逻辑的代码。 Java 虚拟机具体是怎样运行 Java 字节码的？执行 Java 代码首先需要将它编译而成的 class 文件加载到 Java 虚拟机中。加载后的 Java 类会被存放于方法区（Method Area）中。实际运行时，虚拟机会执行方法区内的代码。 Java 字节码无法直接执行。因此，Java 虚拟机需要将字节码翻译成机器码。在 HotSpot 里面，上述翻译过程有两种形式：第一种是解释执行，即逐条将字节码翻译成机器码并执行；第二种是即时编译（Just-In-Time compilation，JIT），即将一个方法中包含的所有字节码编译成机器码后再执行。 前者的优势在于无需等待编译，而后者的优势在于实际运行速度更快。HotSpot 默认采用混合模式，综合了解释执行和即时编译两者的优点。它会先解释执行字节码，而后将其中反复执行的热点代码，以方法为单位进行即时编译。 HotSpot 采用了多种技术来提升启动性能以及峰值性能，即时编译便是其中最重要的技术之一。对于占据大部分的不常用的代码，无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，则可以将其编译成机器码，以达到理想的运行速度。 HotSpot 内置了多个即时编译器：C1、C2 和 Graal。 HotSpot 的即时编译是放在额外的编译线程中进行的。HotSpot 会根据 CPU 的数量设置编译线程的数目，并且按 1:2 的比例配置给 C1 及 C2 编译器。在计算资源充足的情况下，字节码的解释执行和即时编译可同时进行。编译完成后的机器码会在下次调用该方法时启用，以替换原本的解释执行。 java 的基本类型8个基本类型支持数值计算，原因主要是基本类型能够在执行效率以及内存使用两方面提升软件性能。 在 Java 语言规范中，boolean 类型的值只有两种可能，它们分别用符号“true”和“false”来表示。 在 Java 虚拟机规范中，boolean 类型则被映射成 int 类型。true”被映射为整数 1，而“false”被映射为整数 0。这个编码规则约束了 Java 字节码的具体实现。 类型 值域 默认值 虚拟机内部符号 boolean {false,true} false Z byte [-128,127] 0 B short [-32768,32767] 0 S char [0,65535] ‘\u0000’ C int [-2^31,2^31-1] 0 I long [-2^63,2^63-1] 0L J float ~[-3.4E38,3.4E38] +0.0F F double ~[-1.8E308,1.8E308] +0.0D D 在 Java 中，正无穷和负无穷是有确切的值，在内存中分别等同于十六进制整数 0x7F800000 和 0xFF800000。0x7F800001 这个数字对应的浮点数是 NaN（Not-a-Number）。 Java 虚拟机每调用一个 Java 方法，便会创建一个栈帧。 boolean、byte、char、short 这四种类型，在栈上占用的空间和 int 是一样的，和引用类型也是一样的。因此，在 32 位的 HotSpot 中，这些类型在栈上将占用 4 个字节；而在 64 位的 HotSpot 中，他们将占 8 个字节。 Java 虚拟机的算数运算几乎全部依赖于操作数栈。将堆中的 boolean、byte、char 以及 short 加载到操作数栈上，而后将栈上的值当成 int 类型来运算。 Java 虚拟机是如何加载 Java类的Java 语言的类型可以分为两大类：基本类型（primitive types）和引用类型（reference types）。 引用类型，Java 将其细分为四种：类、接口、数组类和泛型参数。由于泛型参数会在编译过程中被擦除，因此 Java 虚拟机实际上只有前三种。在类、接口和数组类中，数组类是由 Java 虚拟机直接生成的，其他两种则有对应的字节流。 字节流，最常见的形式要属由 Java 编译器生成的 class 文件。 加载，是指查找字节流，并且据此创建类的过程。Java 虚拟机则需要借助类加载器来完成查找字节流的过程。启动类加载器。除了启动类加载器之外，其他的类加载器都是 java.lang.ClassLoader 的子类，因此有对应的 Java 对象。在 Java 虚拟机中，这个潜规则有个特别的名字，叫双亲委派模型。每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。 启动类加载器负责加载最为基础、最为重要的类，比如存放在 JRE 的 lib目录下 jar 包中的类（以及由虚拟机参数 -Xbootclasspath 指定的类）。 扩展类加载器的父类加载器是启动类加载器。它负责加载相对次要、但又通用的类，比如存放在 JRE 的 lib/ext 目录下 jar 包中的类（以及由系统变量 java.ext.dirs 指定的类）。 应用类加载器的父类加载器则是扩展类加载器。它负责加载应用程序路径下的类。（这里的应用程序路径，便是指虚拟机参数 -cp/-classpath、系统变量 java.class.path 或环境变量CLASSPATH 所指定的路径。）默认情况下，应用程序中包含的类便是由应用类加载器加载的。 链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。它可分为验证、准备以及解析三个阶段。 验证阶段的目的，在于确保被加载类能够满足 Java 虚拟机的约束条件。 准备阶段的目的，则是为被加载类的静态字段分配内存。Java 代码中对静态字段的具体初始化，则会在稍后的初始化阶段中进行。 解析阶段的目的，正是将这些符号引用解析成为实际引用。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。） 初始化，如果直接赋值的静态字段被 final 所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被 Java 编译器标记成常量值（ConstantValue），其初始化直接由 Java 虚拟机完成。除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同一方法中，并把它命名为 &lt; clinit &gt;。类加载的最后一步是初始化，便是为标记为常量值的字段赋值，以及执行 &lt; clinit &gt; 方法的过程。Java 虚拟机会通过加锁来确保类的 &lt; clinit &gt; 方法仅被执行一次。 类的初始化何时会被触发： 当虚拟机启动时，初始化用户指定的主类； 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类； 当遇到调用静态方法的指令时，初始化该静态方法所在的类； 当遇到访问静态字段的指令时，初始化该静态字段所在的类； 子类的初始化会触发父类的初始化； 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化； 使用反射 API 对某个类进行反射调用时，初始化这个类； 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx]]></title>
    <url>%2F2020%2F02%2F18%2FNginx%2F</url>
    <content type="text"><![CDATA[NginxNginx介绍Nginx(engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了 IMAP/POP3/SMTP 服务。 Nginx的组成 二进制可执行文件：由各模块源码编译出的一个文件 Nginx.conf 配置文件：控制Nginx的行为 access.log访问日志：记录每一条http请求 error.log 错误日志：定位问题 OpenResty：OpenResty是一个基于 Nginx与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。 Nginx的安装与使用安装 从官网下载Nginx二进制文件 解压 ./configure –prefix=PATH 安装路径 –help 查看帮助命令 make make install 使用配置静态web服务器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; # 启用gzip压缩 减少传输数据大小 gzip on; server &#123; listen 8080; server_name localhost; #charset koi8-r; #设置请求日志 access_log logs/geek.access.log main; # 拦截 / 请求，定向到dlib目录文件下 location / &#123; alias dlib/; autoindex on; #root html; #index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&apos;s document root # concurs with nginx&apos;s one # #location ~ /\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; 反向代理openresty配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; upstream local&#123; server 127.0.0.1:8080; &#125; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forward-For $proxy_add_x_forwarded_for; proxy_pass http://local; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&apos;s document root # concurs with nginx&apos;s one # #location ~ /\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; nginx配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; gzip on; server &#123; listen 127.0.0.1:8080; server_name localhost; #charset koi8-r; access_log logs/geek.access.log main; location /report.html&#123; alias /home/geek/nginx/html/report.html; &#125; location / &#123; alias dlib/; autoindex on; #root html; #index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&apos;s document root # concurs with nginx&apos;s one # #location ~ /\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; GoAccessGoAccess 被设计成快速的并基于终端的日志分析工具。其核心理念是不需要通过 Web 浏览器就能快速分析并实时查看 Web 服务器的统计数据。 1goaccess geek.access.log -o ../html/report.html --real-time-html --time-format=%H:%M:%S --date-format=%d/%b/%Y --log-format=COMBINED]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发(七)]]></title>
    <url>%2F2020%2F01%2F21%2F%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[并发（七）CountDownLatch 和 CyclicBarrier任务：优化对账系统 伪代码 12345678910while(存在未对账订单)&#123; // 查询未对账订单 pos = getPOrders(); // 查询派送单 dos = getDOrders(); // 执行对账操作 diff = check(pos, dos); // 差异写入差异库 save(diff);&#125; 并行优化对账系统查询未对账订单 getPOrders() 和查询派送单 getDOrders() 可以并行处理。 主线程需要等待线程 T1 和 T2 执行完才能执行 check() 和 save() 这两个操作，为此我们通过调用 T1.join() 和 T2.join() 来实现等待，当 T1 和 T2 线程退出时，调用 T1.join() 和T2.join() 的主线程就会从阻塞态被唤醒，从而执行之后的 check() 和 save()。 12345678910111213141516171819 while(存在未对账订单)&#123;// 查询未对账订单 Thread T1 = new Thread(()-&gt;&#123; pos = getPOrders(); &#125;); T1.start();// 查询派送单 Thread T2 = new Thread(()-&gt;&#123; dos = getDOrders(); &#125;); T2.start();// 等待 T1、T2 结束 T1.join(); T2.join();// 执行对账操作 diff = check(pos, dos);// 差异写入差异库 save(diff); &#125; CountDownLatch 实现线程等待while 循环里面每次都会创建新的线程，而创建线程可是个耗时的操作。所以最好是创建出来的线程能够循环利用。 1234567891011121314151617181920212223Executor executor = Executors.newFixedThreadPool(2); while(存在未对账订单)&#123; // 计数器初始化为 2 CountDownLatch latch = new CountDownLatch(2); // 查询未对账订单 executor.execute(()-&gt; &#123; pos = getPOrders(); latch.countDown(); &#125;); // 查询派送单 executor.execute(()-&gt; &#123; dos = getDOrders(); latch.countDown(); &#125;); // 等待两个查询操作结束 latch.await(); // 执行对账操作 diff = check(pos, dos); // 差异写入差异库 save(diff); &#125; CyclicBarrier 实现线程同步线程 T1 负责查询订单，当查出一条时，调用 barrier.await() 来将计数器减 1，同时等待计数器变成 0；线程 T2 负责查询派送单，当查出一条时，也调用 barrier.await()来将计数器减 1，同时等待计数器变成 0；当 T1 和 T2 都调用 barrier.await() 的时候，计数器会减到 0，此时 T1 和 T2 就可以执行下一条语句了，同时会调用 barrier 的回调函数来执行对账操作。 1234567891011121314151617181920212223242526272829303132333435363738394041 // 订单队列 Vector&lt;P&gt; pos; // 派送单队列 Vector&lt;D&gt; dos; // 执行回调的线程池 Executor executor = Executors.newFixedThreadPool(1); final CyclicBarrier barrier = new CyclicBarrier(2, ()-&gt;&#123; executor.execute(()-&gt;check()); &#125;); void check()&#123; P p = pos.remove(0); D d = dos.remove(0);// 执行对账操作 diff = check(p, d);// 差异写入差异库 save(diff); &#125; void checkAll()&#123;// 循环查询订单库 Thread T1 = new Thread(()-&gt;&#123; while(存在未对账订单)&#123;// 查询订单库 pos.add(getPOrders());// 等待 barrier.await(); &#125; &#125;); T1.start();// 循环查询运单库 Thread T2 = new Thread(()-&gt;&#123; while(存在未对账订单)&#123;// 查询运单库 dos.add(getDOrders());// 等待 barrier.await(); &#125; &#125;); T2.start(); &#125; 并发容器容器：List、Map、Set和Queue 组合操作需要注意竞态条件问题。组合操作不具备原子性。 ListCopyOnWriteArrayListCopyOnWriteArrayList 内部维护了一个数组，成员变量 array 就指向这个内部数组，所有的读操作都是基于 array 进行的。 遍历 array 的同时，还有一个写操作，例如增加元素。CopyOnWriteArrayList 会将 array 复制一份，然后在新复制处理的数组上执行增加元素的操作，执行完之后再将 array 指向这个新的组。 CopyOnWriteArrayList 仅适用于写操作非常少的场景，而且能够容忍读写的短暂不一致。 MapConcurrentHashMap 和 ConcurrentSkipListMapConcurrentHashMap 的 key 是无序的，而ConcurrentSkipListMap 的 key 是有序的。 集合类 Key Value 是否线程安全 HashMap 允许为Null 允许 否 TreeMap 不允许 允许 否 HashTable 不允许 不允许 是 ConcurrentHashMap 不允许 不允许 是 ConcurrentSkipListMap 不允许 不允许 是 SetCopyOnWriteArraySet 和 ConcurrentSkipListSetQueue一个维度是阻塞与非阻塞，所谓阻塞指的是当队列已满时，入队操作阻塞；当队列已空时，出队操作阻塞。另一个维度是单端与双端，单端指的是只能队尾入队，队首出队；而双端指的是队首队尾皆可入队出队。Java 并发包里阻塞队列都用 Blocking 关键字标识，单端队列使用 Queue 标识，双端队列使用 Deque 标识。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode贪心(一)]]></title>
    <url>%2F2020%2F01%2F17%2Fleetcode3%E8%B4%AA%E5%BF%83%2F</url>
    <content type="text"><![CDATA[leetcode贪心(一)860. 柠檬水找零题目在柠檬水摊上，每一杯柠檬水的售价为 5 美元。 顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。 每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。 注意，一开始你手头没有任何零钱。 如果你能给每位顾客正确找零，返回 true ，否则返回 false 。 1234567输入：[5,5,5,10,20]输出：true解释：前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。由于所有客户都得到了正确的找零，所以我们输出 true。 解答 123456789101112131415161718192021222324252627282930class Solution &#123; public boolean lemonadeChange(int[] bills) &#123; int[] money = &#123;0,0,0&#125;; for(int i = 0; i &lt; bills.length;i++)&#123; if(bills[i] == 5)&#123; money[0] +=1; &#125;else if (bills[i] == 10) &#123; if(money[0] &gt; 0)&#123; money[0] -=1; money[1] +=1; &#125;else&#123; return false; &#125; &#125;else&#123; int ye = 15; if(money[1] &gt; 0)&#123; ye -=10; money[1] -=1; &#125; if(money[0] &gt;= (ye/5))&#123; money[0] -=(ye/5); &#125;else&#123; return false; &#125; &#125; &#125; return true; &#125;&#125; 题解按顺序判断就好，顾客给10元必须有5元的，顾客给20元必须有10元和5元或者3张5元。 455. 分发饼干题目假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 注意： 你可以假设胃口值为正。一个小朋友最多只能拥有一块饼干。 12345678输入: [1,2,3], [1,1]输出: 1解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。 解答1234567891011121314151617181920import java.util.Arrays;class Solution &#123; public int findContentChildren(int[] g, int[] s) &#123; int res = 0; Arrays.sort(g); Arrays.sort(s); for(int i = 0; i &lt; g.length ; i++)&#123; for(int j = 0; j &lt; s.length; j++)&#123; if(g[i] &gt; s[j])&#123; continue; &#125;else&#123; res +=1; s[j] = 0; break; &#125; &#125; &#125; return res; &#125;&#125; 题解先进行排序，把胃口小的和饼干小的放到前面。因为小的不满足大的肯定不满足了。大胃口的可以满足很多小胃口的。 406. 根据身高重建队列假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。 注意：总人数少于1100人。 12345输入:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]输出:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 解答123456789101112class Solution &#123; public int[][] reconstructQueue(int[][] people) &#123; Arrays.sort(people, (o1, o2) -&gt; o1[0] == o2[0] ? o1[1] - o2[1] : o2[0] - o1[0]); LinkedList&lt;int[]&gt; list = new LinkedList&lt;&gt;(); for (int[] i : people) &#123; list.add(i[1], i); &#125; return list.toArray(new int[list.size()][2]); &#125;&#125; 题解 解题思路：先排序再插入 排序规则：按照先H高度降序，K个数升序排序 遍历排序后的数组，根据K插入到K的位置上 核心思想：高个子先站好位，矮个子插入到K位置上，前面肯定有K个高个子，矮个子再插到前面也满足K的要求]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode位运算]]></title>
    <url>%2F2020%2F01%2F17%2Fleetcode2%2F</url>
    <content type="text"><![CDATA[leetcode位运算(二)268. 缺失数字题目给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。 12输入: [3,0,1]输出: 2 解答12345678910class Solution &#123; public int missingNumber(int[] nums) &#123; int res = 0; for(int i = 0 ; i &lt; nums.length;i++)&#123; res = res ^ i ^ nums[i]; &#125; return res ^ nums.length; &#125;&#125; 题解一个数与自身异或为0，0与任何数异或为数本身。 数组长度刚好是n，别忘了最后与n异或。 231. 2的幂题目给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 123输入: 1输出: true解释: 20 = 1 解答1234567891011121314class Solution &#123; public boolean isPowerOfTwo(int n) &#123; if(n &lt;=0)&#123; return false; &#125; int tmp = n &amp; (-n); if ((n ^ tmp) == 0)&#123; return true; &#125;else&#123; return false; &#125; &#125;&#125; 题解2的幂次必定二进制中只有一位是1，所以先求出与n对应最右位为1的数（n &amp; -n）。再与n异或看是否只有一个1。 461. 汉明距离题目两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。 给出两个整数 x 和 y，计算它们之间的汉明距离。 12345678输入: x = 1, y = 4输出: 2解释:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑ 解答1234567891011121314class Solution &#123; public int hammingDistance(int x, int y) &#123; int tmp = x ^ y; int count = 0; int i = 0; while(i &lt; 32)&#123; if(((tmp&gt;&gt;i) &amp; 1) == 1)&#123; count ++; &#125; i++; &#125; return count; &#125;&#125; 题解异或：两个对应位不同取1。 int 求出一个数里位数为1的位置个数。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis hash&list]]></title>
    <url>%2F2019%2F12%2F31%2Fredis%E5%AE%9E%E6%88%982%2F</url>
    <content type="text"><![CDATA[Redis hash&amp;listhash常用操作设置值 1hset key field name 获取值 1hget key field 删除field 1hdel key field [field ...] 计算field个数 1hlen key 批量设置 12hmget key field [field ...]hmset key field value [field value ...] 判断field是否存在 1hexists key field 获取所有field 1hkeys key 获取所有value 1hvals key 获取所有的field-value 1hgetall key hincrby hincrbyfloat 12hincrby key fieldhincrbyfloat key field 计算value的字符串长度(redis3.2) 1hstrlen key field 内部编码 ziplist（压缩列表）：当哈希类型元素个数小于hash-max-ziplist-entries配置（默认512个）、同时所有值都小于hash-max-ziplist-value配置（默认64字节），ziplist使用更加紧凑的结构实现多个元素的连续存储，所以在节省内存方面比hashtable更加优秀。 hashtable（哈希表）：当哈希类型无法满足ziplist的条件时，Redis会使用hashtable作为哈希的内部实现，因为此时ziplist的读写效率会下降，而hashtable的读写时间复杂度为O（1）。 使用场景模拟关系型数据库redis服务端与客户端通信：https://blog.csdn.net/fouy_yun/article/details/81322536 list命令从右边插入元素 1rpush key value [value ...] 以从左到右获取列表的所有元素 1lrange listkey 0 -1 从左边插入元素 1lpush key value [value ...] 向某个元素前或者后插入元素 1linsert key before|after pivot value 获取列表指定索引下标的元素 1lindex key index 获取列表长度 1llen key 从列表左侧弹出元素 1lpop key 从列表右侧弹出 1rpop key 删除指定元素 1lrem key count value 按照索引范围修剪列表 1ltrim key start end 保留 start 到 end 元素 修改指定索引下标的元素 1lset key index newValue 阻塞弹出 12blpop key [key ...] timeoutbrpop key [key ...] timeout 列表为空：如果timeout=3，那么客户端要等到3秒后返回，如果timeout=0，那么客户端一直阻塞等下去 列表不为空：客户端会立即返回 如果多个客户端对同一个键执行brpop，那么最先执行brpop命令的客户端可以获取到弹出的值。 内部编码 ziplist（压缩列表）：当列表的元素个数小于list-max-ziplist-entries配置（默认512个），同时列表中每个元素的值都小于list-max-ziplist-value配置时（默认64字节），Redis会选用ziplist来作为列表的内部实现来减少内存的使用。 linkedlist（链表）：当列表类型无法满足ziplist的条件时，Redis会使用linkedlist作为列表的内部实现。 使用场景消息队列Redis的lpush+brpop命令组合即可实现阻塞队列，生产者客户端使用lrpush从列表左侧插入元素，多个消费者客户端使用brpop命令阻塞式的“抢”列表尾部的元素，多个客户端保证了消费的负载均衡和高可用性。 文章列表keys： lpush+lpop=Stack（栈） lpush+rpop=Queue（队列） lpush+ltrim=Capped Collection（有限集合） lpush+brpop=Message Queue（消息队列）]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode位运算]]></title>
    <url>%2F2019%2F12%2F30%2Fleetcode%E4%BD%8D%E8%BF%90%E7%AE%971%2F</url>
    <content type="text"><![CDATA[leetcode位运算(一)136.只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 123示例输入: [2,2,1]输出: 1 Solution:12345678910class Solution &#123; public int singleNumber(int[] nums) &#123; int a = nums[0]; for(int i = 1; i &lt; nums.length;i++)&#123; a = a ^ nums[i]; &#125; return a; &#125;&#125; 题解：利用位运算规则 一个数和自身取异或值位0。例如：1^1=0。因为每个元素均出现两次，所以偶数的元素最后异或后为0。 0^任何数 = 数本身 137.只出现一次的数字2给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。 123示例输入: [2,2,3,2]输出: 3 Solution:12345678910111213class Solution &#123; public int singleNumber(int[] nums) &#123; int res = 0; for(int i = 0; i &lt; 32; i++)&#123; int sum = 0; for(int j = 0 ; j &lt; nums.length;j++)&#123; sum += (nums[j] &gt;&gt; i) &amp; 1; &#125; res = res | ((sum % 3) &lt;&lt; i); &#125; return res; &#125;&#125; 题解：如果一个数出现k次那么对应为位1的出现k次，除k余0，出现1次的余1。 260.只出现一次的数字3给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。 123示例输入: [1,2,1,3,2,5]输出: [3,5] Solution:12345678910111213141516171819class Solution &#123; public int[] singleNumber(int[] nums) &#123; int[] res = new int[2]; int mask = 0; for(int i = 0; i &lt; nums.length;i++)&#123; mask = mask ^ nums[i]; &#125; mask = mask &amp; (-mask); for(int i = 0 ; i &lt; nums.length;i++)&#123; if((mask &amp; nums[i]) == 0)&#123; res[0] ^= nums[i]; &#125;else&#123; res[1] ^= nums[i]; &#125; &#125; return res; &#125;&#125; 题解：先求mask，将数组里所有元素进行异或操作。因为有a,b两个数不同，所以mask必有一位为1。 mask &amp;= -mask 可以求出最右边为1的位置,其余位置为0。 123456num:5原码：0101反码：1010---------num:-5补码：1011 用mask将数组分成两部分。左边一组对应mask 1位为1，右边一组为0。 两组各取异或即为答案。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发(三)]]></title>
    <url>%2F2019%2F12%2F20%2F%E5%B9%B6%E5%8F%91(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[并发（三）Java线程通用线程生命周期五态模型： 初始状态，指的是线程已经被创建，但是还不允许分配 CPU 执行。这个状态属于编程语言特有的，不过这里所谓的被创建，仅仅是在编程语言层面被创建，而在操作系统层面，真正的线程还没有创建。 可运行状态，指的是线程可以分配 CPU 执行。在这种状态下，真正的操作系统线程已经被成功创建了，所以可以分配 CPU 执行。 当有空闲的 CPU 时，操作系统会将其分配给一个处于可运行状态的线程，被分配到CPU 的线程的状态就转换成了运行状态。 运行状态的线程如果调用一个阻塞的 API（例如以阻塞方式读文件）或者等待某个事件（例如条件变量），那么线程的状态就会转换到休眠状态，同时释放 CPU 使用权，休眠状态的线程永远没有机会获得 CPU 使用权。当等待的事件出现了，线程就会从休眠状态转换到可运行状态。 线程执行完或者出现异常就会进入终止状态，终止状态的线程不会切换到其他任何状态，进入终止状态也就意味着线程的生命周期结束了。 Java 语言里则把可运行状态和运行状态合并 Java中线程生命周期 初始状态 可运行/运行生命状态 休眠状态 BLOCKED 线程等待 synchronized 的隐式锁 线程调用阻塞式 API 时，是不会转换到 BLOCKED 状态，在操作系统层面，线程是会转换到休眠状态的，但是在JVM 层面，Java 线程的状态不会发生变化，也就是说 Java 线程的状态会依然保持RUNNABLE 状态。JVM 层面并不关心操作系统调度相关的状态，因为在 JVM 看来，等待CPU 使用权（操作系统层面此时处于可执行状态）与等待 I/O（操作系统层面此时处于休眠状态）没有区别，都是在等待某个资源，所以都归入了 RUNNABLE 状态。 WAITING 获得 synchronized 隐式锁的线程，调用无参数的 Object.wait() 方法 调用无参数的 Thread.join() 方法 调用 LockSupport.park() 方法 TIMED-WAITING 调用带超时参数的 Thread.sleep(long millis) 方法； 获得 synchronized 隐式锁的线程，调用带超时参数的 Object.wait(long timeout) 方法； 调用带超时参数的 Thread.join(long millis) 方法； 调用带超时参数的 LockSupport.parkNanos(Object blocker, long deadline) 方法； 调用带超时参数的 LockSupport.parkUntil(long deadline) 方法。 终止状态 stop() 方法会真的杀死线程，不给线程喘息的机会，如果线程持有 ReentrantLock 锁，被stop() 的线程并不会自动调用 ReentrantLock 的 unlock() 去释放锁，那其他线程就再也没机会获得 ReentrantLock 锁，这实在是太危险了。所以该方法就不建议使用了，类似的方法还有 suspend() 和 resume() 方法 interrupt() 方法仅仅是通知线程，线程有机会执行一些后续操作。当线程处于阻塞状态时被中断，会通过异常的方式通知。 123456789101112Thread th = Thread.currentThread(); while(true) &#123; if(th.isInterrupted()) &#123; break; &#125; // 省略业务代码无数 try &#123; Thread.sleep(100); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125;&#125; 线程在sleep期间被打断了，抛出一个InterruptedException异常，try catch捕捉此异常，应该重置一下中断标示，因为抛出异常后，中断标示会自动清除掉！ 线程的数量使用多线程的目的：降低延迟，提高吞吐量 方法： 算法优化 将硬件性能发挥到极致，一个是 I/O，一个是 CPU。简言之，在并发编程领域，提升性能本质上就是提升硬件的利用率，再具体点来说，就是提升 I/O的利用率和 CPU 的利用率。 线程数量设定： 对于 CPU 密集型计算，多线程本质上是提升多核 CPU 的利用率，所以对于一个 4 核的CPU，每个核一个线程，理论上创建 4 个线程就可以了，再多创建线程也只是增加线程切换的成本。所以，对于 CPU 密集型的计算场景，理论上“线程的数量 =CPU 核数”就是最合适的。不过在工程上，线程的数量一般会设置为“CPU 核数 +1”，这样的话，当线程因为偶尔的内存页失效或其他原因导致阻塞时，这个额外的线程可以顶上，从而保证CPU 的利用率。 对于 I/O 密集型的计算场景，最佳线程数 =CPU 核数 * [ 1 +（I/O 耗时 / CPU 耗时）] 局部变量不存在线程安全问题局部变量在各自的线程栈里 方法里的局部变量，因为不会和其他线程共享，所以没有并发问题，这个思路很好，已经成为解决并发问题的一个重要技术，同时还有个响当当的名字叫做线程封闭，比较官方的解释是：仅在单线程内访问数据。由于不存在共享，所以即便不同步也不会有并发问题，性能杠杠的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发（二）]]></title>
    <url>%2F2019%2F12%2F20%2F%E5%B9%B6%E5%8F%91(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[并发（二）并发编程常见问题安全性问题正确性：程序按我们期望的顺序执行。 需要仔细检查的情况：存在共享数据并且该数据会发生变化，通俗地讲就是有多个线程会同时读写同一数据。 数据竞争：当多个线程同时访问同一数据，并且至少有一个线程会写这个数据的时候，如果我们不采取防护措施，那么就会导致并发 Bug。 竞态条件：指的是程序的执行结果依赖线程执行的顺序。 123456789101112131415public class Test &#123; private long count = 0; synchronized long get()&#123; return count； &#125; synchronized void set(long v)&#123; count = v; &#125; void add10K() &#123; int idx = 0; while(idx++ &lt; 10000) &#123; set(get()+1) &#125; &#125;&#125; 活跃性问题活跃性问题，指的是某个操作无法执行下去。 死锁 活锁：有时线程虽然没有发生阻塞，但仍然会存在执行不下去的情况 可能会一直没完没了地“谦让”下去，成为没有发生阻塞但依然执行不下去的“活锁”。解决“活锁”的方案很简单，谦让时，尝试等待一个随机的时间就可以了。 饥饿：指的是线程因无法访问所需资源而无法执行下去的情况。 保证资源充足 公平地分配资源 避免持有锁的线程长时间执行 性能问题使用“锁”要非常小心，但是如果小心过度，也可能出“性能问题”。“锁”的过度使用可能导致串行化的范围过大，这样就不能够发挥多线程的优势了，而我们之所以使用多线程搞并发程序，为的就是提升性能。 既然使用锁会带来性能问题，那最好的方案自然就是使用无锁的算法和数据结构了。在这方面有很多相关的技术，例如线程本地存储 (Thread Local Storage, TLS)、写入时复制 (Copy-on-write)、乐观锁等；Java 并发包里面的原子类也是一种无锁的数据结构；Disruptor 则是一个无锁的内存队列，性能都非常好…… 减少锁持有的时间。互斥锁本质上是将并行的程序串行化，所以要增加并行度，一定要减少持有锁的时间。这个方案具体的实现技术也有很多，例如使用细粒度的锁，一个典型的例子就是 Java 并发包里的 ConcurrentHashMap，它使用了所谓分段锁的技术；还可以使用读写锁，也就是读是无锁的，只有写的时候才会互斥。 性能方面的度量指标有很多，我觉得有三个指标非常重要，就是：吞吐量、延迟和并发量。 吞吐量：指的是单位时间内能处理的请求数量。吞吐量越高，说明性能越好。 延迟：指的是从发出请求到收到响应的时间。延迟越小，说明性能越好。 并发量：指的是能同时处理的请求数量，一般来说随着并发量的增加、延迟也会增加。所以延迟这个指标，一般都会是基于并发量来说的。例如并发量是 1000 的时候，延迟是 50 毫秒。 管程管程，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发。 三种不同的管程模型， Hasen 模型、Hoare 模型 和 MESA 模型。其中，现在广泛应用的是 MESA 模型，并且 Java 管程的实现参考的也是 MESA 模型。 管程解决互斥和同步问题： 互斥：即同一时刻只允许一个线程访问共享资源 就是将共享变量及其对共享变量的操作统一封装起来。 同步： 即线程之间如何通信、协作 条件变量和等待队列 假设有个线程 T1 执行出队操作，不过需要注意的是执行出队操作，有个前提条件，就是队列不能是空的，而队列不空这个前提条件就是管程里的条件变量。 如果线程 T1 进入管程 后恰好发现队列是空的，就去条件变量对应的等待队列 里面等。此时线程 T1 就去“队列不空”这个条件变量的等待队列中等待。线程 T1 进入条件变量的等待队列后，是允许其他线程进入管程的。 再假设之后另外一个线程 T2 执行入队操作，入队操作执行成功之后，“队列不空”这个条 件对于线程 T1 来说已经满足了，此时线程 T2 要通知 T1，告诉它需要的条件已经满足了。当线程 T1 得到通知后，会从等待队列里面出来，但是出来之后不是马上执行，而是重新进 入到入口等待队列里面。前面提到线程 T1 发现“队列不空”这个条件不满足，需要进到对应的等待队列里等 待。这个过程就是通过调用 wait() 来实现的。如果我们用对象 A 代表“队列不空”这个条 件，那么线程 T1 需要调用 A.wait()。同理当“队列不空”这个条件满足时，线程 T2 需要 调用 A.notify() 来通知 A 等待队列中的一个线程，此时这个队列里面只有线程 T1。至于 notifyAll() 这个方法，它可以通知等待队列中的所有线程。 管程要求同一时刻只允许一个线程执行，那当线程 T2 的操作使线程 T1 等待的条件满足时，T1 和 T2 究竟谁可以执行呢？ Hasen 模型里面，要求 notify() 放在代码的最后，这样 T2 通知完 T1 后，T2 就结束了，然后 T1 再执行，这样就能保证同一时刻只有一个线程执行。 Hoare 模型里面，T2 通知完 T1 后，T2 阻塞，T1 马上执行；等 T1 执行完，再唤醒 T2，也能保证同一时刻只有一个线程执行。但是相比 Hasen 模型，T2 多了一次阻塞唤 醒操作。 MESA 管程里面，T2 通知完 T1 后，T2 还是会接着执行，T1 并不立即执行，仅仅是从条件变量的等待队列进到入口等待队列里面。这样做的好处是 notify() 不用放到代码的最后，T2 也没有多余的阻塞唤醒操作。但是也有个副作用，就是当 T1 再次执行的时 候，可能曾经满足的条件，现在已经不满足了，所以需要以循环方式检验条件变量。 12345678910111213141516171819202122232425262728293031323334353637383940public class BlockedQueue&lt;T&gt;&#123; final Lock lock = new ReentrantLock(); // 条件变量：队列不满 final Condition notFull = lock.newCondition(); // 条件变量：队列不空 final Condition notEmpty = lock.newCondition(); // 入队 void enq(T x) &#123; lock.lock(); try &#123; while (队列已满)&#123; // 等待队列不满 notFull.await(); &#125; // 省略入队操作... // 入队后, 通知可出队 notEmpty.signal(); &#125;finally &#123; lock.unlock(); &#125; &#125; // 出队 void deq()&#123; lock.lock(); try &#123; while (队列已空)&#123; // 等待队列不空 notEmpty.await(); &#125; // 省略出队操作... // 出队后，通知可入队 notFull.signal(); &#125;finally &#123; lock.unlock(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis--api&字符串]]></title>
    <url>%2F2019%2F12%2F20%2Fredis%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[初始redisRedis是一种基于键值对（key-value）的NoSQL数据库。 Redis中的值可以是由string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合）、Bitmaps（位图）、HyperLogLog、GEO（地理信息定位）等多种数据结构和算法组成。 Redis提供了两种持久化方式：RDB和AOF，即可以用两种策略将内存的数据保存到硬盘中，这样就保证了数据的可持久性。 Redis提供了复制功能，实现了多个相同数据的Redis副本，复制功能是分布式Redis的基础。 redis使用场景： 缓存 排行榜系统 计数器应用 社交网络 消息队列系统 redis api全局命令查看所有键 1keys * 键总数 1dbsize dbsize命令在计算键总数时不会遍历所有键，而是直接获取Redis内置的键总数变量，所以dbsize命令的时间复杂度是O（1）。而keys命令会遍历所有键，所以它的时间复杂度是O（n） 检查键是否存在 1exists key 删除键 1del key 键过期 1expire key seconds ttl命令观察键的剩余过期 键的数据结构类型 1type key 数据结构和内部编码object encoding命令查询内部编码 每种数据结构都有两种以上的内部编码实现，例如list数据结构包含了linkedlist和ziplist两种内部编码。 单线程架构Redis使用了单线程架构和I/O多路复用模型来实现高性能的内存数据库服务。 Redis是单线程来处理命令的，所以一条命令从客户端达到服务端不会立刻被执行，所有命令都会进入一个队列，所以命令执行顺序不确定。 为什么单线程还能这么快 纯内存访问 非阻塞I/O，Redis使用epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间。IO：https://www.cnblogs.com/cainingning/p/9556642.html https://www.cnblogs.com/jeakeven/p/5435916.html 单线程避免了线程切换和竞态产生的消耗。 字符串设置值 1set key value [ex seconds] [px milliseconds] [nx|xx] ex seconds：为键设置秒级过期时间。 px milliseconds：为键设置毫秒级过期时间。 nx：键必须不存在，才可以设置成功，用于添加。 xx：与nx相反，键必须存在，才可以设置成功，用于更新。 获取值 1get key 批量设置值 12mset key value [key value ...]mget key [key ...] 批量操作命令可以有效提高开发效率,减少运行时间。 计数 1incr key key+1 decr:- incrby decrby incrbyfloat 追加值 1append key value 向字符串尾部追加值 字符串长度 1strlen key 设置并返回原值 1getset key value 设置指定位置的字符 1setrange key offest value 获取部分字符串 1getrange key start end 内部编码int：8个字节的长整型 embstr：小于等于39个字节的字符串 raw：大于39个字节的字符串 12object encoding key查看内部编码实现 使用场景 缓存功能redis作为缓存层，mysql作为存储层，redis支撑高并发，加速读写和降低后端压力。 推荐命名方式 业务名:对象名​：id:[属性]​ 计数incr key 共享session将用户session保存到redis中 限速为key设置过期时间]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2019%2F12%2F15%2FGit%2F</url>
    <content type="text"><![CDATA[Git .git object 全增量文件所在地，目录名+里面文件名为全增量的文件名 123git cat-file -p 61ac375fc5565c8a763d942dc599fd34128bdb3761 目录名 ac375fc5565c8a763d942dc599fd34128bdb37文件名查看文件内容 index文件是暂存区 12git ls-files --stage查看内容 HEAD文件描述了当前分支上 Head 的位置 12git config --global user.email &quot;easychen@gmail.com&quot;git config --global user.name &quot;Easy&quot; 创建分支并切换 12git branch devgit checkout dev git merge 分支合并 冲突： 合并失败，运行git merge –abort ，就可以恢复到 merge 之前的状态。 手动处理冲突 git log 查看提交日志 git checkout SHA1 值，我们就可以回到那次提交时的历史。 checkout 后边加上 -b 参数来将其检出为一个全新的分支。 本地没有仓库git clone repo 将远程仓库复制到本地 git remote 命令，我们可以查看到所有关联到当前仓库的远程仓库 git remote show (name)命令，我们可以查看某一个远程仓库的详细信息。 git push 和 git pull 命令，我们可以从服务器端推送和拉取代码。 本地有仓库先在 github 上创建一个空的项目，得到远程仓库地址。然后把它和本地仓库关联起来。 git init git remote add 命令 123git remote remove origingit remote add origin2 https://github.com/easychen/litephp.gitgit remote show origin2 git pull name branch git push name branch git stash 将本次修改暂时存入储藏区，并切回到修改之前的版本 git stash apply ， git 就会自动把之前放到储藏区的最新的那个修改切回来 git stash list 命令，可以把所有放到储藏区的修改都列出来。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL技术内幕（三）]]></title>
    <url>%2F2019%2F12%2F14%2FMysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[MySQL技术内幕（三）索引：https://segmentfault.com/a/1190000019366328?utm_source=tag-newest mysql日志文件：https://blog.csdn.net/u012834750/article/details/79533866 表InnoDB存储引擎表，每张表都有主键，若没有显示定义主键，则按以下方式创建主键： 非空且唯一的索引 自动创建一个6个字节大小的指针 逻辑存储结构 表空间 默认共享表空间 innodb_file_per_table 可单独放到一个表空间，但只包含以下数据：数据、索引、插入缓冲，其他类信息如undo信息、系统事务信息、二次写缓存放在原来的共享表空间内 段 数据段 索引段 回滚段 区 64个页，每个页大小16kb，每个区大小1MB 页（块） 行]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发(六)]]></title>
    <url>%2F2019%2F12%2F13%2F%E5%B9%B6%E5%8F%91(%E5%85%AD)%2F</url>
    <content type="text"><![CDATA[并发（六）StampedLockStampedLock 支持三种模式，分别是： 写锁 悲观读锁 乐观读(无锁) StampedLock 里的写锁和悲观读锁加锁成功之后，都会返回一个 stamp；然后解锁的时候，需要传入这个 stamp。 12345678910111213141516final StampedLock sl = new StampedLock();// 获取 / 释放悲观读锁示意代码 long stamp = sl.readLock(); try &#123;// 省略业务相关代码 &#125; finally &#123; sl.unlockRead(stamp); &#125;// 获取 / 释放写锁示意代码 long stamp = sl.writeLock(); try &#123;// 省略业务相关代码 &#125; finally &#123; sl.unlockWrite(stamp); &#125; ReadWriteLock 支持多个线程同时读，但是当多个线程同时读的时候，所有的写操作会被阻塞；而 StampedLock 提供的乐观读，是允许一个线程获取写锁的，也就是说不是所有的写操作都被阻塞。 StampedLock 读模板123456789101112131415161718192021final StampedLock sl = new StampedLock();// 乐观读 long stamp = sl.tryOptimisticRead();// 读入方法局部变量 ......// 校验 stamp if (!sl.validate(stamp))&#123;// 升级为悲观读锁 stamp = sl.readLock(); try &#123;// 读入方法局部变量 ..... &#125; finally &#123;// 释放悲观读锁 sl.unlockRead(stamp); &#125; &#125;// 使用方法局部变量执行业务操作 ...... StampedLock 写模板1234567long stamp = sl.writeLock();try &#123; // 写共享变量 ...... &#125; finally &#123; sl.unlockWrite(stamp);&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发(五)]]></title>
    <url>%2F2019%2F12%2F08%2F%E5%B9%B6%E5%8F%91(%E4%BA%94)%2F</url>
    <content type="text"><![CDATA[并发（五）Semaphore信号量模型 一个计数器 一个等待队列 三个方法 init：设置计数器的初始值。 up：计数器的值减 1；如果此时计数器的值小于 0，则当前线程将被阻塞，否则当前线程可以继续执行。 down：计数器的值加 1；如果此时计数器的值小于或者等于 0，则唤醒等待队列中的一个线程，并将其从等待队列中移除。 Java SDK 里面，信号量模型是由 java.util.concurrent.Semaphore实现的，Semaphore 这个类能够保证这三个方法都是原子操作。 在 Java SDK 并发包里，down() 和 up() 对应的则是 acquire() 和 release()。 note：管程很难实现多个线程同时访问一个并发变量。 使用–限流器12345678910111213141516171819202122232425class ObjPool&lt;T, R&gt; &#123; final List&lt;T&gt; pool; // 用信号量实现限流器 final Semaphore sem; // 构造函数 ObjPool(int size, T t)&#123; pool = new Vector&lt;T&gt;()&#123;&#125;; for(int i=0; i&lt;size; i++)&#123; pool.add(t); &#125; sem = new Semaphore(size); &#125; // 利用对象池的对象，调用 func R exec(Function&lt;T,R&gt; func) throws InterruptedException &#123; T t = null; sem.acquire(); try &#123; t = pool.remove(0); return func.apply(t); &#125; finally &#123; pool.add(t); sem.release(); &#125; &#125;&#125; ReadWriteLock 实现缓存读写锁（读多写少）读写锁三条原则： 允许多个线程同时读共享变量； 只允许一个线程写共享变量； 如果一个写线程正在执行写操作，此时禁止读线程读共享变量。 缓存数据初始化： 一次性加载的方式 懒加载–按需加载 12345678910111213141516171819202122232425262728293031323334353637class Cache&lt;K,V&gt; &#123; final Map&lt;K, V&gt; m = new HashMap&lt;&gt;(); final ReadWriteLock rwl = new ReentrantReadWriteLock(); final Lock r = rwl.readLock(); final Lock w = rwl.writeLock(); V get(K key) &#123; V v = null;// 读缓存 r.lock(); ① try &#123; v = m.get(key); ② &#125; finally&#123; r.unlock(); ③ &#125;// 缓存中存在，返回 if(v != null) &#123; ④ return v; &#125;// 缓存中不存在，查询数据库 w.lock(); ⑤ try &#123;// 再次验证// 其他线程可能已经查询过数据库 v = m.get(key); ⑥ if(v == null)&#123; ⑦// 查询数据库 v= 省略代码无数 m.put(key, v); &#125; &#125; finally&#123; w.unlock(); &#125; return v; &#125;&#125; 先是获取读锁，然后再升级为写锁，叫锁的升级。可惜 ReadWriteLock 并不支持这种升级。ReentrantReadWriteLock获取读锁的时候线程还是持有写锁的，这种锁的降级是支持的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发(四)]]></title>
    <url>%2F2019%2F11%2F28%2F%E5%B9%B6%E5%8F%91(%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[并发（四）并发两大问题： 互斥 —— lock 同步 —— condition 再造管程原因：一是性能，二是 synchronized 无法解决死锁问题 synchronized 申请资源的时候，如果申请不到，线程直接进入阻塞状态了，而线程进入阻塞状态，啥都干不了，也释放不了线程已经占有的资源。 解决的三种方案： 能够响应中断。synchronized 的问题是，持有锁 A 后，如果尝试获取锁 B 失败，那么线程就进入阻塞状态，一旦发生死锁，就没有任何机会来唤醒阻塞的线程。但如果阻塞状态的线程能够响应中断信号，也就是说当我们给阻塞的线程发送中断信号的时候，能够唤醒它，那它就有机会释放曾经持有的锁 A。 支持超时。如果线程在一段时间之内没有获取到锁，不是进入阻塞状态，而是返回一个错误，那这个线程也有机会释放曾经持有的锁。 非阻塞地获取锁。如果尝试获取锁失败，并不进入阻塞状态，而是直接返回，那这个线程也有机会释放曾经持有的锁。 Java lock接口三个方法： 12345678// 支持中断的 APIvoid lockInterruptibly() throws InterruptedException;// 支持超时的 APIboolean tryLock(long time, TimeUnit unit) throws InterruptedException;// 支持非阻塞获取锁的 APIboolean tryLock(); 保持可见性Java 里多线程的可见性是通过 Happens-Before 规则保证的，而 synchronized 之所以能够保证可见性，也是因为有一条 synchronized 相关的规则：synchronized 的解锁 Happens-Before 于后续对这个锁的加锁。 Java SDK 里面锁的实现非常复杂，原理是：它是利用了 volatile 相关的 Happens-Before 规则。Java SDK里面的 ReentrantLock，内部持有一个 volatile 的成员变量 state，获取锁的时候，会读写state 的值；解锁的时候，也会读写 state 的值。也就是说，在执行 value+=1 之前，程序先读写了一次 volatile 变量 state，在执行 value+=1 之后，又读写了一次 volatile 变量 state。 可重入锁ReentrantLock，这个翻译过来叫可重入锁，所谓可重入锁，指的是线程可以重复获取同一把锁。例如下面代码中，当线程 T1 执行到 ① 处时，已经获取到了锁 rtl ，当在① 处调用 get() 方法时，会在 ② 再次对锁 rtl 执行加锁操作。此时，如果锁 rtl 是可重入的，那么线程 T1 可以再次加锁成功；如果锁 rtl 是不可重入的，那么线程 T1 此时会被阻塞。 12345678910111213141516171819202122232425class X &#123; private final Lock rtl = new ReentrantLock(); int value; public int get() &#123; // 获取锁 rtl.lock(); ② try &#123; return value; &#125; finally &#123; // 保证锁能释放 rtl.unlock(); &#125; &#125; public void addOne() &#123; // 获取锁 rtl.lock(); try &#123; value = 1 + get(); ① &#125; finally &#123; // 保证锁能释放 rtl.unlock(); &#125; &#125;&#125; 公平锁与非公平锁ReentrantLock 这个类有两个构造函数，一个是无参构造函数，一个是传入 fair 参数的构造函数。fair 参数代表的是锁的公平策略，如果传入 true 就表示需要构造一个公平锁，反之则表示要构造一个非公平锁。 123456789// 无参构造函数：默认非公平锁public ReentrantLock() &#123; sync = new NonfairSync();&#125;// 根据公平策略参数创建锁public ReentrantLock(boolean fair)&#123; sync = fair ? new FairSync() : new NonfairSync();&#125; 入口等待队列，锁都对应着一个等待队列，如果一个线程没有获得锁，就会进入等待队列，当有线程释放锁的时候，就需要从等待队列中唤醒一个等待的线程。如果是公平锁，唤醒的策略就是谁等待的时间长，就唤醒谁，很公平；如果是非公平锁，则不提供这个公平保证，有可能等待时间短的线程反而先被唤醒。 使用锁的原则 永远只在更新对象的成员变量时加锁 永远只在访问可变的成员变量时加锁 永远不在调用其他对象的方法时加锁 条件变量Java 语言内置的管程里只有一个条件变量，而 Lock 和 Condition 实现的管程是支持多个条件变量的。 12345678910111213141516171819202122232425262728293031323334353637383940public class BlockedQueue&lt;T&gt;&#123; final Lock lock = new ReentrantLock(); // 条件变量：队列不满 final Condition notFull = lock.newCondition(); // 条件变量：队列不空 final Condition notEmpty = lock.newCondition(); // 入队 void enq(T x) &#123; lock.lock(); try &#123; while (队列已满)&#123; // 等待队列不满 notFull.await(); &#125; // 省略入队操作... // 入队后, 通知可出队 notEmpty.signal(); &#125;finally &#123; lock.unlock(); &#125; &#125; // 出队 void deq()&#123; lock.lock(); try &#123; while (队列已空)&#123; // 等待队列不空 notEmpty.await(); &#125; // 省略出队操作... // 出队后，通知可入队 notFull.signal(); &#125;finally &#123; lock.unlock(); &#125; &#125;&#125; 同步与异步调用方是否需要等待结果，如果需要等待结果，就是同步；如果不需要等待结果，就是异步。 异步实现的两种方式： 调用方创建一个子线程，在子线程中执行方法调用，这种调用我们称为异步调用； 方法实现的时候，创建一个新的线程执行主要逻辑，主线程直接 return，这种方法我们一般称为异步方法。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式（三）]]></title>
    <url>%2F2019%2F11%2F23%2F%E5%88%86%E5%B8%83%E5%BC%8F(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[分布式（三）分布式选举集群一般是由两个或两个以上的服务器组建而成，每个服务器都是一个节点。数据库集群提供了读写功能，管理集群提供了管理、故障恢复等功能。 协同，需要选举“领导”来管理和调控，“领导”称为主节点，选“领导”的过程在分布式领域中叫作分布式选举。 分布式选举算法Bully 算法在所有活着的节点中，选取 ID 最大的节点作为主节点。在 Bully 算法中，节点的角色有两种：普通节点和主节点。初始化时，所有节点都是平等的，都是普通节点，并且都有成为主的权利。但是，当选主成功后，有且仅有一个节点成为主节点，其他所有节点都是普通节点。当且仅当主节点故障或与其他节点失去联系后，才会重新选主。 选举过程需要传递3种消息 Election 消息，用于发起选举； Alive 消息，对 Election 消息的应答； Victory 消息，竞选成功的主节点向其他节点发送的宣誓主权的消息。 假设条件是，集群中每个节点均知道其他节点的 ID 步骤： 集群中每个节点判断自己的 ID 是否为当前活着的节点中 ID 最大的，如果是，则直接向其他节点发送 Victory 消息，宣誓自己的主权； 如果自己不是当前活着的节点中 ID 最大的，则向比自己 ID 大的所有节点发送Election 消息，并等待其他节点的回复； 若在给定的时间范围内，本节点没有收到其他节点回复的 Alive 消息，则认为自己成为主节点，并向其他节点发送 Victory 消息，宣誓自己成为主节点；若接收到来自比自己ID 大的节点的 Alive 消息，则等待其他节点发送 Victory 消息； 若本节点收到比自己 ID 小的节点发送的 Election 消息，则回复一个 Alive 消息，告知其他节点，我比你大，重新选举。 MongoDB 的副本集故障转移功能 Raft 算法多数派投票选举算法,少数服从多数 集群节点的角色有 3 种： Leader，即主节点，同一时刻只有一个 Leader，负责协调和管理其他节点； Candidate，即候选者，每一个节点都可以成为 Candidate，节点在该角色下才可以被选为新的 Leader； Follower，Leader 的跟随者，不可以发起选举。 选举流程： 初始化时，所有节点均为 Follower 状态。 开始选主时，所有节点的状态由 Follower 转化为 Candidate，并向其他节点发送选举请求。 其他节点根据接收到的选举请求的先后顺序，回复是否同意成为主。这里需要注意的是，在每一轮选举中，一个节点只能投出一张票。 若发起选举请求的节点获得超过一半的投票，则成为主节点，其状态转化为 Leader，其他节点的状态则由 Candidate 降为 Follower。Leader 节点与 Follower 节点之间会定期发送心跳包，以检测主节点是否活着。 当 Leader 节点的任期到了，即发现其他服务器开始下一轮选主周期时，Leader 节点的状态由 Leader 降级为 Follower，进入新一轮选主。 Kubernetes ZAB 算法ZAB（ZooKeeper Atomic Broadcast）选举算法是为 ZooKeeper 实现分布式协调功能而设计的。相较于 Raft 算法的投票机制，ZAB 算法增加了通过节点 ID 和数据 ID 作为参考进行选主，节点 ID 和数据 ID 越大，表示数据越新，优先成为主。相比较于 Raft 算法，ZAB 算法尽可能保证数据的最新性。所以，ZAB 算法可以说是对 Raft 算法的改进。 集群中每个节点拥有 3 种角色： Leader，主节点； Follower，跟随者节点； Observer，观察者，无投票权。 集群中的节点拥有 4 个状态： Looking 状态，即选举状态。当节点处于该状态时，它会认为当前集群中没有 Leader，因此自己进入选举状态。 Leading 状态，即领导者状态，表示已经选出主，且当前节点为 Leader。 Following 状态，即跟随者状态，集群中已经选出主后，其他非主节点状态更新为Following，表示对 Leader 的追随。 Observing 状态，即观察者状态，表示当前节点为 Observer，持观望态度，没有投票权和选举权。 每个节点都有一个唯一的三元组 (server_id, server_zxID, epoch)，其中server_id 表示本节点的唯一 ID；server_zxID 表示本节点存放的数据 ID，数据 ID 越大表示数据越新，选举权重越大；epoch 表示当前选取轮数，一般用逻辑时钟表示。ZAB 选举算法的核心是“少数服从多数，ID 大的节点优先成为主”，因此选举过程中通过(vote_id, vote_zxID) 来表明投票给哪个节点，其中 vote_id 表示被投票节点的 ID，vote_zxID 表示被投票节点的服务器 zxID。ZAB 算法选主的原则是：server_zxID 最大者成为 Leader；若 server_zxID 相同，则 server_id 最大者成为 Leader。 Raft选主算法通常采用奇数节点]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习（一）]]></title>
    <url>%2F2019%2F11%2F18%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[机器学习（绪论+第一章）绪论机器学习定义定义：假设用P来评估计算机程序在某一任务T上的性能，若某一程序通过利用经验E在T中任务上获得了性能改善，则我们就说关于T和P，该程序对E进行了学习。 术语 数据集 样本 属性或特征 训练集和测试集 分类 回归 聚类 监督学习和无监督学习 泛化能力 假设空间 归纳：从特殊到一般 演绎：从一般到特殊 归纳偏好 奥卡姆剃刀原则 模型评估与选择错误率 and 精度 训练误差 and 泛化误差 过拟合 and 欠拟合 评估方法 留出法：分层采样 交叉验证 自助法]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>研究</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式（二）]]></title>
    <url>%2F2019%2F11%2F17%2F%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[分布式（二）分布式互斥集中式算法引入一个协调者，将所有的请求者进行排序，最早请求的参与者可以使用临界资源 优点： 简单、易于实现 通信高效 缺点： 可用性低 性能易受协调者影响 应用场景： 在协调者的可靠性和性能有一定保证的情况下，可以适用于比较广泛的场景 分布式算法征求其他参与者同意后，可以使用资源 优点： 可用性比较高 缺点： 通信成本高 复杂度高 应用场景： 适合临界资源访问频率较低且规模较少的系统 令牌环算法所有参与者组成一个环，轮流使用临界资源 优点： 单个参与者通信效率较高 可用性较高 缺点： 当临界资源使用频率较低时，会带来较多无用通信 适用场景： 系统规模较小，并且系统中每个程序使用临界资源频率较高，且使用时间短的场景]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL技术内幕（二）]]></title>
    <url>%2F2019%2F11%2F16%2FMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[MySQL技术内幕（二）文件参数文件告诉MySQL实例启动时在哪里可以找到数据库文件，并指定某些初始化参数。 show variables； 参数类型： 动态参数：在MySQL实例运行过程中可以修改 静态参数：在整个实例的生命周期内不得修改 日志文件 错误文件：MySQL启动、运行、关闭进行了记录，数据库优化 慢查询日志：为SQL语句的优化带来帮助。设置long_query_time,将超过阈值的写入到慢查询日志 查询日志：所有对MySQL数据库请求信息 二进制日志：对数据库执行的更改操作。 恢复 复制 socket文件UNIX系统下连接数据库可以使用套接字 pid文件实例启动时，会把自己进程id写进到一个文件中 MySql表结构文件.frm文件 存储引擎文件 表空间文件 默认会初始化10MB，名为ibdata1的文件 单独.ibd文件 重做日志文件 事务恢复]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式（一）]]></title>
    <url>%2F2019%2F11%2F16%2F%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[分布式（一）分布式的起源单机模式所有应用程序和数据均部署在一台电脑或服务器上，由一台计算机完成所有的处理。 存在问题：性能受限、存在单点失效问题。 数据分布式并行计算采用消息共享模式使用多台计算机并行运行或执行多项任务，核心原理是每台计算机上执行相同的程序，将数据进行拆分放到不同的计算机上进行计算。 将应用与数据分离，分别部署到不同的服务器上 对数据进行拆分，比如把同一类型的数据拆分到两个甚至更多的数据库中，这样应用服务器上的任务就可以针对不同数据并行执行了。 需要负载均衡 读写IO数据库操作较大，因此加入缓存机制 问题：对提升单个任务的执行性能及降低时延无效。 任务分布式任务并行指的是，将单个复杂的任务拆分为多个子任务，从而使得多个子任务可以在不同的计算机上并行执行。 分布式：分布式其实就是将相同或相关的程序运行在多台计算机上，从而实现特定目标的一种计算方式。 分布式系统衡量指标性能 吞吐量：系统在一定时间内可以处理的任务数。 QPS，即查询数每秒，用于衡量一个系统每秒处理的查询数。这个指标通常用于读操作，越高说明对读操作的支持越好。 TPS，即事务数每秒，用于衡量一个系统每秒处理的事务数。这个指标通常对应于写操作，越高说明对写操作的支持越好。 BPS，即比特数每秒，用于衡量一个系统每秒处理的数据量。 响应时间：系统响应一个请求或输入需要花费的时间。 完成时间：系统真正完成一个请求或处理需要花费的时间。 资源资源占用指的是，一个系统提供正常能力需要占用的硬件资源，比如 CPU、内存、硬盘等。 空载资源占用： 一个系统在没有任何负载时的资源占用 满载资源占用： 一个系统满额负载时的资源占用 可用性和可拓展性可用性，通常指的是系统在面对各种异常时可以正确提供服务的能力。 可靠性通常用来表示一个系统完全不出故障的概率，更多地用在硬件领域。 当任务的需求随着具体业务不断提高时，除了升级系统的性能做垂直 / 纵向扩展外，另一个做法就是通过增加机器的方式去水平 / 横向扩展系统规模。 不同业务对分布式系统要求： 电商系统。对于一个电商系统而言，系统设计者最看重的是吞吐量，为了处理更多的用户访问或订单业务，甚至不惜牺牲一些硬件成本。 IoT。对于一个 IoT 系统而言，设计者最看重的是资源占用指标，因为在一些功能极简的 IoT 设备上 RAM、ROM 的可用资源通常都是 KB 级的。 电信业务。对于电信业务而言，最重要的无疑是响应时间、完成时间，以及可用性。因为，你在打电话时不希望你的声音半天才被对方听到，也不希望半天才听到对方的回应， 更不希望你的电话无法拨出。 HPC。HPC 系统最显著的特点是任务执行时间极长，一个天体物理任务的分析和计算通常耗时数周甚至数月。因此，通过水平扩展来提高系统的加速比，是 HPC 系统设计者需要关注的。 大数据。大数据任务的处理时间可能相对 HPC 系统来讲比较短，但常见的完成时间也达到了小时级，所以扩展性也是大数据系统首先要考虑的。 云计算。对于一个云计算系统而言，常见任务是虚拟主机或容器的创建、资源调整、销毁等操作，如何减少这些操作的完成时间，从而提升用户体验是设计者们要重点关注的。另 外，云计算系统本质上卖的是资源，那么降低系统本身的资源开销，也是系统设计的重中之重。 区块链。区块链的吞吐量比较低，比特币的 TPS 只有 7 次每秒，单平均一次交易的确认 就需要 10 分钟左右，因此吞吐量和完成时间通常是区块链系统设计者的首要目标。]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发（一）]]></title>
    <url>%2F2019%2F11%2F14%2F%E5%B9%B6%E5%8F%91(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[并发（一）并发编程bug源头可见性 原因：多核CPU有各自的缓存，，线程 A 操作的是 CPU-1 上的缓存，而线程 B 操作的是 CPU-2 上的缓存，很明显，这个时候线程 A 对变量 V 的操作对于线程 B 而言就不具备可见性了。 可见性是指一个线程对共享变量的修改，另外一个线程能够立刻看到。 原子性 原因：线程的切换 任务切换的时机大多数是在时间片结束的时候，我们现在基本都使用高级语言编程，高级语言里一条语句往往需要多条 CPU 指令完成。 有序性 原因：编译优化 例子：双重检查创建单例对象，如果new的时候先返回地址，另一个线程可能会引发空指针异常 123456789101112public class Singleton &#123; static Singleton instance; static Singleton getInstance()&#123; if (instance == null) &#123; synchronized(Singleton.class) &#123; if (instance == null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 32位操作系统，long的加减存在并发问题，原因：原子性，对long的加减需要多条CPU指令。 Java内存模型解决可见性和有序性的问题解决问题关键：禁用CPU缓存和禁止编译优化 Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法： volatile synchronized final 六项Happens-Before 规则 12345678910111213class VolatileExample &#123; int x = 0; volatile boolean v = false; public void writer() &#123; x = 42; v = true; &#125; public void reader() &#123; if (v == true) &#123; // 这里 x 会是多少呢？ &#125; &#125;&#125; 1.5之前可能是42，也可能是0，1.5之后是42. Happens-Before 规则含义：前面一个操作的结果对后续操作是可见的 规则： 程序的顺序性规则：按照程序顺序，前面的操作 Happens-Before 于后续的任意操作 volatile 变量规则：对一个 volatile 变量的写操作相对于后续对这个 volatile 变量的读操作可见 传递性：A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。 管程中锁的规则：管程是一种通用的同步原语，在Java 中指的就是 synchronized，synchronized 是 Java 里对管程的实现。解锁可见于后面加锁。 线程 start() 规则：主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作 线程 join() 规则：它是指主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的操作。 final关键字 final 修饰变量时，初衷是告诉编译器：这个变量生而不变，可以可劲儿优化。 加锁本质就是在锁对象的对象头中写入当前线程id，new出来只在一个地方使用的对象，其它线 程不能对它解锁，这个锁会被编译器优化掉。 互斥锁原子性问题产生的原因是线程的切换。单核cpu下可以通过禁止线程切换解决问题，但多核cpu则存在问题。 互斥： 同一时刻只有一个线程执行 。 简易的锁模型加锁–&gt;临界区–&gt;解锁 改进后的锁模型锁和锁要保护的资源是有对应关系 创建受保护资源的锁 加锁操作 临界区 解锁操作 Java提供的锁技术： synchronized 修饰代码块的时候，锁定了一个指定对象 当修饰静态方法的时候，锁定的是当前类的 Class 对象 当修饰非静态方法的时候，锁定的是当前实例对象 this 锁和受保护资源的关系受保护资源和锁之间的关联关系是 N:1 的关系，即可以一把锁保护多个资源。 保护没有关联关系的多个资源 针对没有关联关系的多个资源分别设置不同的锁，也可以用同一把锁，但性能较低 用不同的锁对受保护 资源进行精细化管理，能够提升性能。这种锁还有个名字，叫细粒度锁。 保护有关联关系的多个资源 用同一把锁来保护多个资源，也就是现实世界的“包场”，那在编程领域应该怎么“包场”呢？很简单，只要我们的锁能覆盖所有受保护资源就可以了。但同一锁在不同线程之间传递会存在问题。 用 Account.class 作为共享的锁 。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL技术内幕（一）]]></title>
    <url>%2F2019%2F10%2F30%2FMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[MySQL技术内幕（一）数据库：物理操作系统文件或其他类型文件集合 如果表格b采用MyISAM，在数据库/usr/local/mysql/data/user 中会产生3个文件： b.frm ：描述表结构文件，字段长度等 b.MYD(MYData)：数据信息文件，存储数据信息(如果采用独立表存储模式) b.MYI(MYIndex)：索引信息文件。 如果表格b采用InnoDB，在数据库/usr/local/mysql/data/user中会产生1个或者2个文件： b.frm ：描述表结构文件，字段长度等 如果采用独立表存储模式，/usr/local/mysql/data/user中还会产生b.ibd文件（存储数据信息和索引信息） 如果采用共存储模式的，数据信息和索引信息都存储在ibdata1中 数据库实例：有数据库后台进程/线程以及一个共享内存区组成，数据库实例用来操作数据库文件 MySQL设计为单进程多线程架构。 启动实例时，MySQL会读取配置文件，根据配置文件启动数据库。没有配置文件不会报错，根据默认参数，而Oracle会。 MySQL由以下几部分组成： 连接池组件 管理服务和工具组件 SQL接口组件 查询分析器组件 优化器组件 缓冲组件 插件式存储引擎 物理文件 存储引擎是基于表的。 InnoDB 存储引擎InnoDB 体系架构 内存池 缓存池：缓存各种数据，将数据库文件按页读到缓冲池，按最近最少使用算法保留缓冲池中的数据。数据库文件修改，先修改缓存池的页，再按一定频率将脏页刷新到文件。 缓存数据类型： 索引页 数据页 undo页（ https://blog.csdn.net/alexdamiao/article/details/51872477 ） 插入缓存 自适应哈希索引 锁信息 数据字典信息 重做日志缓冲池：重做日志信息 额外内存池：一些数据结构分配内存需要从该区申请 后台线程：负责刷新内存池中的数据，保证缓冲池中的内存缓存的是最近的数据。将已修改的数据文件刷新到磁盘，同时在异常情况下恢复 后台线程7个：4个IO线程，1个master线程，1个锁线程，1个错误监控线程 关键特性 插入缓冲（性能） 对于非聚集的辅助索引，数据页的存放还是按主键id的执行顺序存放。对于非聚集索引，叶子节点的插入不是顺序的。先判断插入的非聚集索引页是否在缓冲池里，如果在，直接插入。不在先放入插入缓冲区中，再按一定的频率执行插入缓冲和非聚集索引的叶子节点进行合并操作。 前提条件： 索引是辅助索引 索引不是唯一的（原因：如果唯一，又需要查找索引页的情况，出现离散读的情况，插入缓冲失去了意义） 两次写（可靠性） 内存 doublewrite buffer 物理磁盘上共享表空间 脏页刷新时，先将脏页拷贝到内存doublewrite buffer，然后每次写1mb到共享表空间，马上同步磁盘 自适应哈希 InnoDB监控对表上索引的查找，如果观察到建立哈希索引可以加速，则建立。通过缓冲池的B+树构造，按频率为页建立，不需要将整个表都建哈希索引。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库（三）]]></title>
    <url>%2F2019%2F10%2F25%2F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SQLSQL数据定义基本类型 char(n) 固定长度，字符长度不够，后面追加空格 varchar(n) 可变长度 int numeric(p,d) p个数，小数点后为d位 float(n) n为精度 基本模式定义 creat 主键 外键 完整性约束 SQL查询单关系查询多关系查询]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>DBMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java文件]]></title>
    <url>%2F2019%2F10%2F06%2Fjava%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[Java 文件路径 文件位于项目根目录下 1InputStream in = new BufferedInputStream(new FileInputStream("src/main/resources/test.properties")); 文件位于类路径下，可利用Class对象或者ClassLoader对象去在类路径下查找文件 12InputStream in = p.getClass().getResourceAsStream("/test.properties");InputStream in = p.getClass().getClassLoader().getResourceAsStream("test.properties"); 注意： Class对象的getResourceAsStream(String path)中的path可以以 / 开头，也可以不以 / 开头。若以 / 开头，表示在类路径根目录下查找，不以 / 开头，表示在当前.java文件编译后.class文件所在的目录中找 ClassLoader对象的getResourceAsStream(String path)中的path不以/开头！，表示在类路径根目录下查找]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库（二）]]></title>
    <url>%2F2019%2F10%2F05%2F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据库（二）关系数据库关系数据的结构由表的集合构成，表中的一行代表一组值之间的联系。表与关系这个概念紧密相连。 n个值之间的联系可以用n-元组表示，对应于表中的一行。 关系&lt;–&gt;表 元组&lt;–&gt;行 属性&lt;–&gt;列 域：关系每个属性允许取值的集合，域要求是原子的 空值（null） 数据库模式数据库模式：数据库逻辑设计 数据库实例：数据库数据的快照 关系模式：类似于类型定义 关系实例：类似于变量的值 码（key）超码（superkey）：这些属性的组合可以使我们在一个关系中唯一的标识一个元组。 候选码（candidatekey）：超码的最小子集 主码（primary key）：由数据库表设计者选中的，用于主要区分不同元组的候选码 主码应该选择那些值从不和极少发生变化的属性 外码（foreign key）：一个关系（r1）模式可能在他的属性中包括另一个关系（r2）的主码。r1也被称为外码依赖的参照关系，r2外码的被参照关系。 关系查询语言 过程化语言 用户指导系统对数据库进行一系列操作以计算出所需的结果 非过程化语言 用户只需要描述出所需的信息，而不用给出具体过程 关系运算]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>DBMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库（一）]]></title>
    <url>%2F2019%2F10%2F04%2F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据库（一）数据库概念文件处理系统弊端： 数据的冗余和不一致 数据访问困难 数据孤立 完整性问题（约束） 原子性问题（例如转账操作） 并发访问异常 安全性问题 数据库系统 = 数据 + 修改数据的程序 数据视图抽象视图：隐藏数据存储和维护的细节 数据抽象 物理层：详细描述底层复杂结构 逻辑层 视图层 实例和模式实例：存储在数据库信息的集合 模式：数据库的总体设计 物理模式 逻辑模式 子模式 数据模型数据模型是一种描述数据、数据联系、数据语义以及一致性约束的概念工具的集合。数据模型提供了一种描述物理层、逻辑层以及视图层数据库设计的方式。 关系模型 E-R模型 基于对象的数据模型 半结构化数据模型 数据库语言 数据操纵语言（DML） 增删改查 数据定义语言（DDL） 数据存储与定义 域约束 参照完整性 断言 授权 DDL的输出放入数据字典中，数据字典包含了元数据。 数据存储与查询数据库系统的功能部件大致可以分为存储管理器和查询处理部件 存储管理器：与操作系统文件系统交互 权限及完整性管理器：完整性约束，用户权限 事务管理器：事务的执行 文件管理器：磁盘存储与分配 缓冲区管理器：决定哪些数据从磁盘上转移到内存缓冲区中 实现的数据结构： 数据文件：数据库本身 数据字典：数据库模式，元数据：数据的数据 索引 查询处理器 DDL解释器：解释DDL语句并记录在数据字典 DML编译器：翻译成执行方案，产生低级指令 查询执行引擎：执行低级指令 事务管理 一致性 原子性 持久性 事务：数据库应用中完成单一逻辑功能的操作集合 事务管理器： 并发控制管理器 恢复管理器]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>DBMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis源码分析（一）]]></title>
    <url>%2F2019%2F10%2F02%2FMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Mybatis 源码分析（一）参考：一本小小的MyBatis源码分析书 Mybatis 入门Mybatis 是什么？ MyBatis 是一种半自动化的 Java 持久层框架（persistence framework），其通过注解或 XML的方式将对象和 SQL 关联起来。半自动是因为和 Hibernate 等一些可自动生成SQL的ORM(Object Relational Mapping)框架相比，使用MyBatis需要用户自行维护SQL。 与 JDBC 对比jdbc 缺点: 代码繁琐，冗余 拼接 SQL 可能会导致 SQL 出错 SQL 写在代码中，如果要改动 SQL，就需要到代码中进行更改 手动从 ResultSet中取出数据 用户需要自行处理受检异常 Mybatis: SqlSessionFactory 是一个工厂类，一旦被创建就应该在应用运行期间一直存在，不应该丢弃或重建。SqlSession 不是线程安全的，所以不应被多线程共享。官方推荐的使用方式是有按需创建，用完即销毁。 使用 MyBatis 无需处理受检异常 SQL 写在配置文件中，进行集中管理，利于维护。同时将 SQL 从代码中剥离，在提高代码的可读性的同时，也避免了拼接 SQL 可能会导致的错误 将查询结果映射为相应的对象 JDBC 可看做是一种基础服务，MyBatis 则是构建在基础服务之上的框架。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM（二）]]></title>
    <url>%2F2019%2F09%2F25%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[深入理解 JVM（二）编译：创建完源文件之后，程序先要被JVM中的java编译器进行编译为.class文件。java编译一个类时，若这个类所依赖的类还没有被编译，编译器会自动的先编译这个所依赖的类，然后引用；若java编译器在指定的目录下找不到该类所依赖的类的 .class文件或者 .java源文件，就会报”Can’t found sysbol”的异常错误。 编译后的字节码文件格式主要分为两部分：常量池和方法字节码。 类加载与常量常量在编译阶段会存入到调用这个常量的方法所在的类的常量池中。 本质上，调用类并没有直接引用到定义常量的类，因此并不会触发定义常量的类的初始化。 当一个常量的值并非编译期间可以确定的，那么其值就不会被放到调用类的常量池中，当这程序在运行时，会导致主动使用这个常量所在的类，显然会导致这个类的初始化。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap知识点]]></title>
    <url>%2F2019%2F09%2F19%2FHashMap%2F</url>
    <content type="text"><![CDATA[HashMapHashMap 定义HashMap是基于哈希表实现的，每一个元素是一个key-value对，其内部通过数组和单链表实现。 HashMap 工作原理HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。 put() 方法实现步骤 对Key求Hash值，然后再计算下标 如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的Hash值相同，需要放到同一个bucket中） 如果碰撞了，以链表的方式链接到后面 如果链表长度超过阀值( TREEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于6，就把红黑树转回链表 如果节点已经存在就替换旧值 如果桶（数组）满了(容量16*加载因子0.75)，就需要 resize（扩容2倍后重排） get() 方法 HashMap会使用键对象的hashcode找到bucket位置，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。 hash 函数如何计算hash函数作用：根据hashcode() 求出其对应数组下标的位置 原理： 高16bit不变，低16bit和高16bit做了一个异或 (n·1)&amp;hash jdk1.8 源码： 1234567891011static final int hash(Object key) &#123; if (key == null)&#123; return 0; &#125; int h; h=key.hashCode()；返回散列值也就是hashcode // ^ ：按位异或 // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐 //其中n是数组的长度，即Map的数组部分初始化长度 return (n-1)&amp;(h ^ (h &gt;&gt;&gt; 16));&#125; 红黑树红黑树的性质 每个节点非红即黑 根节点总是黑色的 如果节点是红色的，则它的子节点必须是黑色的（反之不一定） 每个叶子节点都是黑色的空节点（NIL节点） 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度） 为什么选择使用红黑树二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。 HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。这个值只可能在两个地方，一个是原下标的位置，另一种是在下标为&lt;原下标+原容量&gt;的位置。 解决冲突其他办法 开放定址法 线性探查法 二次探查法 双重散列法 HashTable 数组 + 链表方式存储 默认容量：11(质数为宜) 索引计算 : （key.hashCode() &amp; 0x7FFFFFFF）% table.length 若在链表中找到了，则替换旧值，若未找到则继续 当总元素个数超过容量*加载因子时，扩容为原来 2 倍并重新散列。 将新元素加到链表头部 对修改 Hashtable 内部共享数据的方法添加了 synchronized，保证线程安全。 HashMap 与 HashTable 的区别 Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类。但二者都实现了Map接口。 HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey。Hashtable则保留了contains，containsValue和containsKey三个方法，其中contains和containsValue功能相同。 默认容量不同，扩容不同。计算索引方式不同。 线程安全性，HashTable 安全 效率不同 HashTable 要慢因为加锁 hashmap 键值可以设置为空值，hashtable 不可以。hashmap 将null存到table[0]中去了。 ConcurrentHashMap 原理CocurrentHashMap 与 Hashtable 加锁方式对比Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。它们都可以用于多线程的环境，但是当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。因为ConcurrentHashMap引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需要等到迭代完成才能访问map。简而言之，在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM（一）]]></title>
    <url>%2F2019%2F08%2F30%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[深入理解 JVM课程参考：http://www.iprogramming.cn 类加载Java 中类型的加载、连接和初始化过程都是在程序运行期间完成。 类型：类本身而不是实例化的对象。 加载：类的class文件从磁盘加载到内存中。 将.class文件中的二进制数据读入到内存中，放入运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象，用来封装在方法区内的数据结构。 连接：将类与类之间的关系确定好，检验字节码文件。 验证：类的正确性。 准备：类的静态变量分配内存，初始化为默认值。 解析：类中符号引用转为直接引用。 初始化：类的静态变量赋予正确的初始值，首次主动使用。 类加载器作用：将类加载到内存。 类的使用与卸载 使用 卸载 类的使用方式 主动使用 创建类的实例 访问某个类或接口静态变量或赋值 调用类的静态方法 反射 初始化一个类的子类 启动类的类 动态语言的支持 被动使用 不会导致类的初始化 1234567891011121314151617181920public class MyTest1 &#123; public static void main(String[] args) &#123; System.out.println(Child.str1); &#125;&#125;class Parent&#123; static String str1 = "123"; static &#123; System.out.println("Parent static block"); &#125;&#125;class Child extends Parent&#123; static String str2 = "234"; static &#123; System.out.println("child static block"); &#125;&#125; 结果 12Parent static block123 分析 对于静态字段来说，只有直接定义了该字段的类才会被初始化 1234567891011121314151617181920public class MyTest1 &#123; public static void main(String[] args) &#123; System.out.println(Child.str2); &#125;&#125;class Parent&#123; static String str1 = "123"; static &#123; System.out.println("Parent static block"); &#125;&#125;class Child extends Parent&#123; static String str2 = "234"; static &#123; System.out.println("child static block"); &#125;&#125; 结果 123Parent static blockchild static block234 分析 当一个类初始化时，要求其父类全部初始化完毕。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Java多线程操作（一）]]></title>
    <url>%2F2019%2F08%2F24%2Fthread%2F</url>
    <content type="text"><![CDATA[线程线程基本概念线程是 CPU 调度的基本单位，进程是 CPU 分配资源的基本单位。 Java 中的多线程Java 中创建多线程的两种方式 通过继承Thread类，并重写run方法创建线程 1234567class MyThread extends Thread&#123; @Override public void run() &#123; System.out.println("hello thread!"); &#125;&#125; 通过实现Runnable接口，并传递给Thread类，创建线程。 1234567class MyThread2 implements Runnable&#123; @Override public void run() &#123; System.out.println("hello thread2!"); &#125;&#125; Java 中的线程生命周期 线程新建状态 使用 Java 创建线程的两种方法，创建一个新的线程。 线程就绪状态 通过调用新线程的start()方法使之进入就绪状态 运行中的线程失去CPU运行时间进入就绪状态 阻塞状态的线程处理完阻塞进入就绪状态 线程运行状态 就绪状态的线程一旦获得CPU便进入运行状态 线程阻塞状态 使用线程的sleep()方法 运行状态中的线程执行wait()方法 线程死亡状态 线程生命周期结束 Java 线程同步Java 多个线程同时抢夺资源，造成冲突问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Bank&#123; int i = 0; void add()&#123; i++; &#125; int getI()&#123; return i; &#125;&#125;class MyThread extends Thread&#123; Bank bank; MyThread(Bank b)&#123; bank = b; &#125; @Override public void run() &#123; for(int x = 0; x &lt; 10; x++) &#123; bank.add(); System.out.println(Thread.currentThread().getName() + " value: " +bank.getI()); &#125; &#125; &#125;public class Demo &#123; public static void main(String[] args) &#123; Bank bank = new Bank(); MyThread myThread = new MyThread(bank); myThread.start(); MyThread myThread2 = new MyThread(bank); myThread2.start(); MyThread myThread3 = new MyThread(bank); myThread3.start(); &#125;&#125; 运行结果： 12345Thread-0 value: 2Thread-0 value: 4Thread-2 value: 3Thread-1 value: 2Thread-2 value: 6 同步方法 使用synchronized关键字 由于 Java 的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。 123public synchronized void add()&#123; i++; &#125; 同步代码块 有synchronized关键字修饰的语句块，被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。必须使用同一个锁。 12345public void add()&#123; synchronized (this) &#123; i++; &#125; &#125; 使用特殊域变量(volatile)实现线程同步 volatile具有synchronized关键字的“可见性”，但是没有synchronized关键字的“并发正确性”，也就是说不保证线程执行的有序性。 volatile变量对于每次使用，线程都能得到当前volatile变量的最新值。但是volatile变量并不保证并发的正确性。 1volatile int i = 0; https://www.hollischuang.com/archives/2648 使用重入锁（Lock）实现线程同步 123ReentrantLock() : 创建一个ReentrantLock实例 lock() : 获得锁 unlock() : 释放锁 123456789class Bank&#123; volatile int i = 0; private Lock lock = new ReentrantLock(); void add()&#123; lock.lock(); i++; lock.unlock(); &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>

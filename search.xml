<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[并发(六)]]></title>
    <url>%2F2019%2F12%2F13%2F%E5%B9%B6%E5%8F%91(%E5%85%AD)%2F</url>
    <content type="text"><![CDATA[并发（六）StampedLockStampedLock 支持三种模式，分别是： 写锁 悲观读锁 乐观读(无锁) StampedLock 里的写锁和悲观读锁加锁成功之后，都会返回一个 stamp；然后解锁的时候，需要传入这个 stamp。 12345678910111213141516final StampedLock sl = new StampedLock();// 获取 / 释放悲观读锁示意代码 long stamp = sl.readLock(); try &#123;// 省略业务相关代码 &#125; finally &#123; sl.unlockRead(stamp); &#125;// 获取 / 释放写锁示意代码 long stamp = sl.writeLock(); try &#123;// 省略业务相关代码 &#125; finally &#123; sl.unlockWrite(stamp); &#125; ReadWriteLock 支持多个线程同时读，但是当多个线程同时读的时候，所有的写操作会被阻塞；而 StampedLock 提供的乐观读，是允许一个线程获取写锁的，也就是说不是所有的写操作都被阻塞。 StampedLock 读模板123456789101112131415161718192021final StampedLock sl = new StampedLock();// 乐观读 long stamp = sl.tryOptimisticRead();// 读入方法局部变量 ......// 校验 stamp if (!sl.validate(stamp))&#123;// 升级为悲观读锁 stamp = sl.readLock(); try &#123;// 读入方法局部变量 ..... &#125; finally &#123;// 释放悲观读锁 sl.unlockRead(stamp); &#125; &#125;// 使用方法局部变量执行业务操作 ...... StampedLock 写模板1234567long stamp = sl.writeLock();try &#123; // 写共享变量 ...... &#125; finally &#123; sl.unlockWrite(stamp);&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发(五)]]></title>
    <url>%2F2019%2F12%2F08%2F%E5%B9%B6%E5%8F%91(%E4%BA%94)%2F</url>
    <content type="text"><![CDATA[并发（五）Semaphore信号量模型 一个计数器 一个等待队列 三个方法 init：设置计数器的初始值。 up：计数器的值减 1；如果此时计数器的值小于 0，则当前线程将被阻塞，否则当前线程可以继续执行。 down：计数器的值加 1；如果此时计数器的值小于或者等于 0，则唤醒等待队列中的一个线程，并将其从等待队列中移除。 Java SDK 里面，信号量模型是由 java.util.concurrent.Semaphore实现的，Semaphore 这个类能够保证这三个方法都是原子操作。 在 Java SDK 并发包里，down() 和 up() 对应的则是 acquire() 和 release()。 note：管程很难实现多个线程同时访问一个并发变量。 使用–限流器12345678910111213141516171819202122232425class ObjPool&lt;T, R&gt; &#123; final List&lt;T&gt; pool; // 用信号量实现限流器 final Semaphore sem; // 构造函数 ObjPool(int size, T t)&#123; pool = new Vector&lt;T&gt;()&#123;&#125;; for(int i=0; i&lt;size; i++)&#123; pool.add(t); &#125; sem = new Semaphore(size); &#125; // 利用对象池的对象，调用 func R exec(Function&lt;T,R&gt; func) throws InterruptedException &#123; T t = null; sem.acquire(); try &#123; t = pool.remove(0); return func.apply(t); &#125; finally &#123; pool.add(t); sem.release(); &#125; &#125;&#125; ReadWriteLock 实现缓存读写锁（读多写少）读写锁三条原则： 允许多个线程同时读共享变量； 只允许一个线程写共享变量； 如果一个写线程正在执行写操作，此时禁止读线程读共享变量。 缓存数据初始化： 一次性加载的方式 懒加载–按需加载 12345678910111213141516171819202122232425262728293031323334353637class Cache&lt;K,V&gt; &#123; final Map&lt;K, V&gt; m = new HashMap&lt;&gt;(); final ReadWriteLock rwl = new ReentrantReadWriteLock(); final Lock r = rwl.readLock(); final Lock w = rwl.writeLock(); V get(K key) &#123; V v = null;// 读缓存 r.lock(); ① try &#123; v = m.get(key); ② &#125; finally&#123; r.unlock(); ③ &#125;// 缓存中存在，返回 if(v != null) &#123; ④ return v; &#125;// 缓存中不存在，查询数据库 w.lock(); ⑤ try &#123;// 再次验证// 其他线程可能已经查询过数据库 v = m.get(key); ⑥ if(v == null)&#123; ⑦// 查询数据库 v= 省略代码无数 m.put(key, v); &#125; &#125; finally&#123; w.unlock(); &#125; return v; &#125;&#125; 先是获取读锁，然后再升级为写锁，叫锁的升级。可惜 ReadWriteLock 并不支持这种升级。ReentrantReadWriteLock获取读锁的时候线程还是持有写锁的，这种锁的降级是支持的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发(四)]]></title>
    <url>%2F2019%2F11%2F28%2F%E5%B9%B6%E5%8F%91(%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[并发（四）并发两大问题： 互斥 —— lock 同步 —— condition 再造管程原因：一是性能，二是 synchronized 无法解决死锁问题 synchronized 申请资源的时候，如果申请不到，线程直接进入阻塞状态了，而线程进入阻塞状态，啥都干不了，也释放不了线程已经占有的资源。 解决的三种方案： 能够响应中断。synchronized 的问题是，持有锁 A 后，如果尝试获取锁 B 失败，那么线程就进入阻塞状态，一旦发生死锁，就没有任何机会来唤醒阻塞的线程。但如果阻塞状态的线程能够响应中断信号，也就是说当我们给阻塞的线程发送中断信号的时候，能够唤醒它，那它就有机会释放曾经持有的锁 A。 支持超时。如果线程在一段时间之内没有获取到锁，不是进入阻塞状态，而是返回一个错误，那这个线程也有机会释放曾经持有的锁。 非阻塞地获取锁。如果尝试获取锁失败，并不进入阻塞状态，而是直接返回，那这个线程也有机会释放曾经持有的锁。 Java lock接口三个方法： 12345678// 支持中断的 APIvoid lockInterruptibly() throws InterruptedException;// 支持超时的 APIboolean tryLock(long time, TimeUnit unit) throws InterruptedException;// 支持非阻塞获取锁的 APIboolean tryLock(); 保持可见性Java 里多线程的可见性是通过 Happens-Before 规则保证的，而 synchronized 之所以能够保证可见性，也是因为有一条 synchronized 相关的规则：synchronized 的解锁 Happens-Before 于后续对这个锁的加锁。 Java SDK 里面锁的实现非常复杂，原理是：它是利用了 volatile 相关的 Happens-Before 规则。Java SDK里面的 ReentrantLock，内部持有一个 volatile 的成员变量 state，获取锁的时候，会读写state 的值；解锁的时候，也会读写 state 的值。也就是说，在执行 value+=1 之前，程序先读写了一次 volatile 变量 state，在执行 value+=1 之后，又读写了一次 volatile 变量 state。 可重入锁ReentrantLock，这个翻译过来叫可重入锁，所谓可重入锁，指的是线程可以重复获取同一把锁。例如下面代码中，当线程 T1 执行到 ① 处时，已经获取到了锁 rtl ，当在① 处调用 get() 方法时，会在 ② 再次对锁 rtl 执行加锁操作。此时，如果锁 rtl 是可重入的，那么线程 T1 可以再次加锁成功；如果锁 rtl 是不可重入的，那么线程 T1 此时会被阻塞。 12345678910111213141516171819202122232425class X &#123; private final Lock rtl = new ReentrantLock(); int value; public int get() &#123; // 获取锁 rtl.lock(); ② try &#123; return value; &#125; finally &#123; // 保证锁能释放 rtl.unlock(); &#125; &#125; public void addOne() &#123; // 获取锁 rtl.lock(); try &#123; value = 1 + get(); ① &#125; finally &#123; // 保证锁能释放 rtl.unlock(); &#125; &#125;&#125; 公平锁与非公平锁ReentrantLock 这个类有两个构造函数，一个是无参构造函数，一个是传入 fair 参数的构造函数。fair 参数代表的是锁的公平策略，如果传入 true 就表示需要构造一个公平锁，反之则表示要构造一个非公平锁。 123456789// 无参构造函数：默认非公平锁public ReentrantLock() &#123; sync = new NonfairSync();&#125;// 根据公平策略参数创建锁public ReentrantLock(boolean fair)&#123; sync = fair ? new FairSync() : new NonfairSync();&#125; 入口等待队列，锁都对应着一个等待队列，如果一个线程没有获得锁，就会进入等待队列，当有线程释放锁的时候，就需要从等待队列中唤醒一个等待的线程。如果是公平锁，唤醒的策略就是谁等待的时间长，就唤醒谁，很公平；如果是非公平锁，则不提供这个公平保证，有可能等待时间短的线程反而先被唤醒。 使用锁的原则 永远只在更新对象的成员变量时加锁 永远只在访问可变的成员变量时加锁 永远不在调用其他对象的方法时加锁 条件变量Java 语言内置的管程里只有一个条件变量，而 Lock 和 Condition 实现的管程是支持多个条件变量的。 12345678910111213141516171819202122232425262728293031323334353637383940public class BlockedQueue&lt;T&gt;&#123; final Lock lock = new ReentrantLock(); // 条件变量：队列不满 final Condition notFull = lock.newCondition(); // 条件变量：队列不空 final Condition notEmpty = lock.newCondition(); // 入队 void enq(T x) &#123; lock.lock(); try &#123; while (队列已满)&#123; // 等待队列不满 notFull.await(); &#125; // 省略入队操作... // 入队后, 通知可出队 notEmpty.signal(); &#125;finally &#123; lock.unlock(); &#125; &#125; // 出队 void deq()&#123; lock.lock(); try &#123; while (队列已空)&#123; // 等待队列不空 notEmpty.await(); &#125; // 省略出队操作... // 出队后，通知可入队 notFull.signal(); &#125;finally &#123; lock.unlock(); &#125; &#125;&#125; 同步与异步调用方是否需要等待结果，如果需要等待结果，就是同步；如果不需要等待结果，就是异步。 异步实现的两种方式： 调用方创建一个子线程，在子线程中执行方法调用，这种调用我们称为异步调用； 方法实现的时候，创建一个新的线程执行主要逻辑，主线程直接 return，这种方法我们一般称为异步方法。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式（三）]]></title>
    <url>%2F2019%2F11%2F23%2F%E5%88%86%E5%B8%83%E5%BC%8F(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[分布式（三）分布式选举集群一般是由两个或两个以上的服务器组建而成，每个服务器都是一个节点。数据库集群提供了读写功能，管理集群提供了管理、故障恢复等功能。 协同，需要选举“领导”来管理和调控，“领导”称为主节点，选“领导”的过程在分布式领域中叫作分布式选举。 分布式选举算法Bully 算法在所有活着的节点中，选取 ID 最大的节点作为主节点。在 Bully 算法中，节点的角色有两种：普通节点和主节点。初始化时，所有节点都是平等的，都是普通节点，并且都有成为主的权利。但是，当选主成功后，有且仅有一个节点成为主节点，其他所有节点都是普通节点。当且仅当主节点故障或与其他节点失去联系后，才会重新选主。 选举过程需要传递3种消息 Election 消息，用于发起选举； Alive 消息，对 Election 消息的应答； Victory 消息，竞选成功的主节点向其他节点发送的宣誓主权的消息。 假设条件是，集群中每个节点均知道其他节点的 ID 步骤： 集群中每个节点判断自己的 ID 是否为当前活着的节点中 ID 最大的，如果是，则直接向其他节点发送 Victory 消息，宣誓自己的主权； 如果自己不是当前活着的节点中 ID 最大的，则向比自己 ID 大的所有节点发送Election 消息，并等待其他节点的回复； 若在给定的时间范围内，本节点没有收到其他节点回复的 Alive 消息，则认为自己成为主节点，并向其他节点发送 Victory 消息，宣誓自己成为主节点；若接收到来自比自己ID 大的节点的 Alive 消息，则等待其他节点发送 Victory 消息； 若本节点收到比自己 ID 小的节点发送的 Election 消息，则回复一个 Alive 消息，告知其他节点，我比你大，重新选举。 MongoDB 的副本集故障转移功能 Raft 算法多数派投票选举算法,少数服从多数 集群节点的角色有 3 种： Leader，即主节点，同一时刻只有一个 Leader，负责协调和管理其他节点； Candidate，即候选者，每一个节点都可以成为 Candidate，节点在该角色下才可以被选为新的 Leader； Follower，Leader 的跟随者，不可以发起选举。 选举流程： 初始化时，所有节点均为 Follower 状态。 开始选主时，所有节点的状态由 Follower 转化为 Candidate，并向其他节点发送选举请求。 其他节点根据接收到的选举请求的先后顺序，回复是否同意成为主。这里需要注意的是，在每一轮选举中，一个节点只能投出一张票。 若发起选举请求的节点获得超过一半的投票，则成为主节点，其状态转化为 Leader，其他节点的状态则由 Candidate 降为 Follower。Leader 节点与 Follower 节点之间会定期发送心跳包，以检测主节点是否活着。 当 Leader 节点的任期到了，即发现其他服务器开始下一轮选主周期时，Leader 节点的状态由 Leader 降级为 Follower，进入新一轮选主。 Kubernetes ZAB 算法ZAB（ZooKeeper Atomic Broadcast）选举算法是为 ZooKeeper 实现分布式协调功能而设计的。相较于 Raft 算法的投票机制，ZAB 算法增加了通过节点 ID 和数据 ID 作为参考进行选主，节点 ID 和数据 ID 越大，表示数据越新，优先成为主。相比较于 Raft 算法，ZAB 算法尽可能保证数据的最新性。所以，ZAB 算法可以说是对 Raft 算法的改进。 集群中每个节点拥有 3 种角色： Leader，主节点； Follower，跟随者节点； Observer，观察者，无投票权。 集群中的节点拥有 4 个状态： Looking 状态，即选举状态。当节点处于该状态时，它会认为当前集群中没有 Leader，因此自己进入选举状态。 Leading 状态，即领导者状态，表示已经选出主，且当前节点为 Leader。 Following 状态，即跟随者状态，集群中已经选出主后，其他非主节点状态更新为Following，表示对 Leader 的追随。 Observing 状态，即观察者状态，表示当前节点为 Observer，持观望态度，没有投票权和选举权。 每个节点都有一个唯一的三元组 (server_id, server_zxID, epoch)，其中server_id 表示本节点的唯一 ID；server_zxID 表示本节点存放的数据 ID，数据 ID 越大表示数据越新，选举权重越大；epoch 表示当前选取轮数，一般用逻辑时钟表示。ZAB 选举算法的核心是“少数服从多数，ID 大的节点优先成为主”，因此选举过程中通过(vote_id, vote_zxID) 来表明投票给哪个节点，其中 vote_id 表示被投票节点的 ID，vote_zxID 表示被投票节点的服务器 zxID。ZAB 算法选主的原则是：server_zxID 最大者成为 Leader；若 server_zxID 相同，则 server_id 最大者成为 Leader。 Raft选主算法通常采用奇数节点]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发(三)]]></title>
    <url>%2F2019%2F11%2F23%2F%E5%B9%B6%E5%8F%91(%E4%B8%89)%20%2F</url>
    <content type="text"><![CDATA[并发（三）Java线程通用线程生命周期五态模型： 初始状态，指的是线程已经被创建，但是还不允许分配 CPU 执行。这个状态属于编程语言特有的，不过这里所谓的被创建，仅仅是在编程语言层面被创建，而在操作系统层面，真正的线程还没有创建。 可运行状态，指的是线程可以分配 CPU 执行。在这种状态下，真正的操作系统线程已经被成功创建了，所以可以分配 CPU 执行。 当有空闲的 CPU 时，操作系统会将其分配给一个处于可运行状态的线程，被分配到CPU 的线程的状态就转换成了运行状态。 运行状态的线程如果调用一个阻塞的 API（例如以阻塞方式读文件）或者等待某个事件（例如条件变量），那么线程的状态就会转换到休眠状态，同时释放 CPU 使用权，休眠状态的线程永远没有机会获得 CPU 使用权。当等待的事件出现了，线程就会从休眠状态转换到可运行状态。 线程执行完或者出现异常就会进入终止状态，终止状态的线程不会切换到其他任何状态，进入终止状态也就意味着线程的生命周期结束了。 Java 语言里则把可运行状态和运行状态合并 Java中线程生命周期 初始状态 可运行/运行生命状态 休眠状态 BLOCKED 线程等待 synchronized 的隐式锁 线程调用阻塞式 API 时，是不会转换到 BLOCKED 状态，在操作系统层面，线程是会转换到休眠状态的，但是在JVM 层面，Java 线程的状态不会发生变化，也就是说 Java 线程的状态会依然保持RUNNABLE 状态。JVM 层面并不关心操作系统调度相关的状态，因为在 JVM 看来，等待CPU 使用权（操作系统层面此时处于可执行状态）与等待 I/O（操作系统层面此时处于休眠状态）没有区别，都是在等待某个资源，所以都归入了 RUNNABLE 状态。 WAITING 获得 synchronized 隐式锁的线程，调用无参数的 Object.wait() 方法 调用无参数的 Thread.join() 方法 调用 LockSupport.park() 方法 TIMED-WAITING 调用带超时参数的 Thread.sleep(long millis) 方法； 获得 synchronized 隐式锁的线程，调用带超时参数的 Object.wait(long timeout) 方法； 调用带超时参数的 Thread.join(long millis) 方法； 调用带超时参数的 LockSupport.parkNanos(Object blocker, long deadline) 方法； 调用带超时参数的 LockSupport.parkUntil(long deadline) 方法。 终止状态 stop() 方法会真的杀死线程，不给线程喘息的机会，如果线程持有 ReentrantLock 锁，被stop() 的线程并不会自动调用 ReentrantLock 的 unlock() 去释放锁，那其他线程就再也没机会获得 ReentrantLock 锁，这实在是太危险了。所以该方法就不建议使用了，类似的方法还有 suspend() 和 resume() 方法 interrupt() 方法仅仅是通知线程，线程有机会执行一些后续操作。当线程处于阻塞状态时被中断，会通过异常的方式通知。 123456789101112Thread th = Thread.currentThread(); while(true) &#123; if(th.isInterrupted()) &#123; break; &#125; // 省略业务代码无数 try &#123; Thread.sleep(100); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125;&#125; 线程在sleep期间被打断了，抛出一个InterruptedException异常，try catch捕捉此异常，应该重置一下中断标示，因为抛出异常后，中断标示会自动清除掉！ 线程的数量使用多线程的目的：降低延迟，提高吞吐量 方法： 算法优化 将硬件性能发挥到极致，一个是 I/O，一个是 CPU。简言之，在并发编程领域，提升性能本质上就是提升硬件的利用率，再具体点来说，就是提升 I/O的利用率和 CPU 的利用率。 线程数量设定： 对于 CPU 密集型计算，多线程本质上是提升多核 CPU 的利用率，所以对于一个 4 核的CPU，每个核一个线程，理论上创建 4 个线程就可以了，再多创建线程也只是增加线程切换的成本。所以，对于 CPU 密集型的计算场景，理论上“线程的数量 =CPU 核数”就是最合适的。不过在工程上，线程的数量一般会设置为“CPU 核数 +1”，这样的话，当线程因为偶尔的内存页失效或其他原因导致阻塞时，这个额外的线程可以顶上，从而保证CPU 的利用率。 对于 I/O 密集型的计算场景，最佳线程数 =CPU 核数 * [ 1 +（I/O 耗时 / CPU 耗时）] 局部变量不存在线程安全问题局部变量在各自的线程栈里 方法里的局部变量，因为不会和其他线程共享，所以没有并发问题，这个思路很好，已经成为解决并发问题的一个重要技术，同时还有个响当当的名字叫做线程封闭，比较官方的解释是：仅在单线程内访问数据。由于不存在共享，所以即便不同步也不会有并发问题，性能杠杠的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发（二）]]></title>
    <url>%2F2019%2F11%2F20%2F%E5%B9%B6%E5%8F%91(%E4%BA%8C)%20%2F</url>
    <content type="text"><![CDATA[并发（二）并发编程常见问题安全性问题正确性：程序按我们期望的顺序执行。 需要仔细检查的情况：存在共享数据并且该数据会发生变化，通俗地讲就是有多个线程会同时读写同一数据。 数据竞争：当多个线程同时访问同一数据，并且至少有一个线程会写这个数据的时候，如果我们不采取防护措施，那么就会导致并发 Bug。 竞态条件：指的是程序的执行结果依赖线程执行的顺序。 123456789101112131415public class Test &#123; private long count = 0; synchronized long get()&#123; return count； &#125; synchronized void set(long v)&#123; count = v; &#125; void add10K() &#123; int idx = 0; while(idx++ &lt; 10000) &#123; set(get()+1) &#125; &#125;&#125; 活跃性问题活跃性问题，指的是某个操作无法执行下去。 死锁 活锁：有时线程虽然没有发生阻塞，但仍然会存在执行不下去的情况 可能会一直没完没了地“谦让”下去，成为没有发生阻塞但依然执行不下去的“活锁”。解决“活锁”的方案很简单，谦让时，尝试等待一个随机的时间就可以了。 饥饿：指的是线程因无法访问所需资源而无法执行下去的情况。 保证资源充足 公平地分配资源 避免持有锁的线程长时间执行 性能问题使用“锁”要非常小心，但是如果小心过度，也可能出“性能问题”。“锁”的过度使用可能导致串行化的范围过大，这样就不能够发挥多线程的优势了，而我们之所以使用多线程搞并发程序，为的就是提升性能。 既然使用锁会带来性能问题，那最好的方案自然就是使用无锁的算法和数据结构了。在这方面有很多相关的技术，例如线程本地存储 (Thread Local Storage, TLS)、写入时复制 (Copy-on-write)、乐观锁等；Java 并发包里面的原子类也是一种无锁的数据结构；Disruptor 则是一个无锁的内存队列，性能都非常好…… 减少锁持有的时间。互斥锁本质上是将并行的程序串行化，所以要增加并行度，一定要减少持有锁的时间。这个方案具体的实现技术也有很多，例如使用细粒度的锁，一个典型的例子就是 Java 并发包里的 ConcurrentHashMap，它使用了所谓分段锁的技术；还可以使用读写锁，也就是读是无锁的，只有写的时候才会互斥。 性能方面的度量指标有很多，我觉得有三个指标非常重要，就是：吞吐量、延迟和并发量。 吞吐量：指的是单位时间内能处理的请求数量。吞吐量越高，说明性能越好。 延迟：指的是从发出请求到收到响应的时间。延迟越小，说明性能越好。 并发量：指的是能同时处理的请求数量，一般来说随着并发量的增加、延迟也会增加。所以延迟这个指标，一般都会是基于并发量来说的。例如并发量是 1000 的时候，延迟是 50 毫秒。 管程管程，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发。 三种不同的管程模型， Hasen 模型、Hoare 模型 和 MESA 模型。其中，现在广泛应用的是 MESA 模型，并且 Java 管程的实现参考的也是 MESA 模型。 管程解决互斥和同步问题： 互斥：即同一时刻只允许一个线程访问共享资源 就是将共享变量及其对共享变量的操作统一封装起来。 同步： 即线程之间如何通信、协作 条件变量和等待队列 假设有个线程 T1 执行出队操作，不过需要注意的是执行出队操作，有个前提条件，就是队列不能是空的，而队列不空这个前提条件就是管程里的条件变量。 如果线程 T1 进入管程 后恰好发现队列是空的，就去条件变量对应的等待队列 里面等。此时线程 T1 就去“队列不空”这个条件变量的等待队列中等待。线程 T1 进入条件变量的等待队列后，是允许其他线程进入管程的。 再假设之后另外一个线程 T2 执行入队操作，入队操作执行成功之后，“队列不空”这个条 件对于线程 T1 来说已经满足了，此时线程 T2 要通知 T1，告诉它需要的条件已经满足了。当线程 T1 得到通知后，会从等待队列里面出来，但是出来之后不是马上执行，而是重新进 入到入口等待队列里面。前面提到线程 T1 发现“队列不空”这个条件不满足，需要进到对应的等待队列里等 待。这个过程就是通过调用 wait() 来实现的。如果我们用对象 A 代表“队列不空”这个条 件，那么线程 T1 需要调用 A.wait()。同理当“队列不空”这个条件满足时，线程 T2 需要 调用 A.notify() 来通知 A 等待队列中的一个线程，此时这个队列里面只有线程 T1。至于 notifyAll() 这个方法，它可以通知等待队列中的所有线程。 管程要求同一时刻只允许一个线程执行，那当线程 T2 的操作使线程 T1 等待的条件满足时，T1 和 T2 究竟谁可以执行呢？ Hasen 模型里面，要求 notify() 放在代码的最后，这样 T2 通知完 T1 后，T2 就结束了，然后 T1 再执行，这样就能保证同一时刻只有一个线程执行。 Hoare 模型里面，T2 通知完 T1 后，T2 阻塞，T1 马上执行；等 T1 执行完，再唤醒 T2，也能保证同一时刻只有一个线程执行。但是相比 Hasen 模型，T2 多了一次阻塞唤 醒操作。 MESA 管程里面，T2 通知完 T1 后，T2 还是会接着执行，T1 并不立即执行，仅仅是从条件变量的等待队列进到入口等待队列里面。这样做的好处是 notify() 不用放到代码的最后，T2 也没有多余的阻塞唤醒操作。但是也有个副作用，就是当 T1 再次执行的时 候，可能曾经满足的条件，现在已经不满足了，所以需要以循环方式检验条件变量。 12345678910111213141516171819202122232425262728293031323334353637383940public class BlockedQueue&lt;T&gt;&#123; final Lock lock = new ReentrantLock(); // 条件变量：队列不满 final Condition notFull = lock.newCondition(); // 条件变量：队列不空 final Condition notEmpty = lock.newCondition(); // 入队 void enq(T x) &#123; lock.lock(); try &#123; while (队列已满)&#123; // 等待队列不满 notFull.await(); &#125; // 省略入队操作... // 入队后, 通知可出队 notEmpty.signal(); &#125;finally &#123; lock.unlock(); &#125; &#125; // 出队 void deq()&#123; lock.lock(); try &#123; while (队列已空)&#123; // 等待队列不空 notEmpty.await(); &#125; // 省略出队操作... // 出队后，通知可入队 notFull.signal(); &#125;finally &#123; lock.unlock(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习（一）]]></title>
    <url>%2F2019%2F11%2F18%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[机器学习（绪论+第一章）绪论机器学习定义定义：假设用P来评估计算机程序在某一任务T上的性能，若某一程序通过利用经验E在T中任务上获得了性能改善，则我们就说关于T和P，该程序对E进行了学习。 术语 数据集 样本 属性或特征 训练集和测试集 分类 回归 聚类 监督学习和无监督学习 泛化能力 假设空间 归纳：从特殊到一般 演绎：从一般到特殊 归纳偏好 奥卡姆剃刀原则 模型评估与选择错误率 and 精度 训练误差 and 泛化误差 过拟合 and 欠拟合 评估方法 留出法：分层采样 交叉验证 自助法]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>研究</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式（二）]]></title>
    <url>%2F2019%2F11%2F17%2F%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[分布式（二）分布式互斥集中式算法引入一个协调者，将所有的请求者进行排序，最早请求的参与者可以使用临界资源 优点： 简单、易于实现 通信高效 缺点： 可用性低 性能易受协调者影响 应用场景： 在协调者的可靠性和性能有一定保证的情况下，可以适用于比较广泛的场景 分布式算法征求其他参与者同意后，可以使用资源 优点： 可用性比较高 缺点： 通信成本高 复杂度高 应用场景： 适合临界资源访问频率较低且规模较少的系统 令牌环算法所有参与者组成一个环，轮流使用临界资源 优点： 单个参与者通信效率较高 可用性较高 缺点： 当临界资源使用频率较低时，会带来较多无用通信 适用场景： 系统规模较小，并且系统中每个程序使用临界资源频率较高，且使用时间短的场景]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL技术内幕（二）]]></title>
    <url>%2F2019%2F11%2F16%2FMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[MySQL技术内幕（二）文件参数文件告诉MySQL实例启动时在哪里可以找到数据库文件，并指定某些初始化参数。 show variables； 参数类型： 动态参数：在MySQL实例运行过程中可以修改 静态参数：在整个实例的生命周期内不得修改 日志文件 错误文件：MySQL启动、运行、关闭进行了记录，数据库优化 慢查询日志：为SQL语句的优化带来帮助。设置long_query_time,将超过阈值的写入到慢查询日志 查询日志：所有对MySQL数据库请求信息 二进制日志：对数据库执行的更改操作。 恢复 复制 socket文件UNIX系统下连接数据库可以使用套接字 pid文件实例启动时，会把自己进程id写进到一个文件中 MySql表结构文件.frm文件 存储引擎文件 表空间文件 默认会初始化10MB，名为ibdata1的文件 单独.ibd文件 重做日志文件 事务恢复]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式（一）]]></title>
    <url>%2F2019%2F11%2F16%2F%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[分布式（一）分布式的起源单机模式所有应用程序和数据均部署在一台电脑或服务器上，由一台计算机完成所有的处理。 存在问题：性能受限、存在单点失效问题。 数据分布式并行计算采用消息共享模式使用多台计算机并行运行或执行多项任务，核心原理是每台计算机上执行相同的程序，将数据进行拆分放到不同的计算机上进行计算。 将应用与数据分离，分别部署到不同的服务器上 对数据进行拆分，比如把同一类型的数据拆分到两个甚至更多的数据库中，这样应用服务器上的任务就可以针对不同数据并行执行了。 需要负载均衡 读写IO数据库操作较大，因此加入缓存机制 问题：对提升单个任务的执行性能及降低时延无效。 任务分布式任务并行指的是，将单个复杂的任务拆分为多个子任务，从而使得多个子任务可以在不同的计算机上并行执行。 分布式：分布式其实就是将相同或相关的程序运行在多台计算机上，从而实现特定目标的一种计算方式。 分布式系统衡量指标性能 吞吐量：系统在一定时间内可以处理的任务数。 QPS，即查询数每秒，用于衡量一个系统每秒处理的查询数。这个指标通常用于读操作，越高说明对读操作的支持越好。 TPS，即事务数每秒，用于衡量一个系统每秒处理的事务数。这个指标通常对应于写操作，越高说明对写操作的支持越好。 BPS，即比特数每秒，用于衡量一个系统每秒处理的数据量。 响应时间：系统响应一个请求或输入需要花费的时间。 完成时间：系统真正完成一个请求或处理需要花费的时间。 资源资源占用指的是，一个系统提供正常能力需要占用的硬件资源，比如 CPU、内存、硬盘等。 空载资源占用： 一个系统在没有任何负载时的资源占用 满载资源占用： 一个系统满额负载时的资源占用 可用性和可拓展性可用性，通常指的是系统在面对各种异常时可以正确提供服务的能力。 可靠性通常用来表示一个系统完全不出故障的概率，更多地用在硬件领域。 当任务的需求随着具体业务不断提高时，除了升级系统的性能做垂直 / 纵向扩展外，另一个做法就是通过增加机器的方式去水平 / 横向扩展系统规模。 不同业务对分布式系统要求： 电商系统。对于一个电商系统而言，系统设计者最看重的是吞吐量，为了处理更多的用户访问或订单业务，甚至不惜牺牲一些硬件成本。 IoT。对于一个 IoT 系统而言，设计者最看重的是资源占用指标，因为在一些功能极简的 IoT 设备上 RAM、ROM 的可用资源通常都是 KB 级的。 电信业务。对于电信业务而言，最重要的无疑是响应时间、完成时间，以及可用性。因为，你在打电话时不希望你的声音半天才被对方听到，也不希望半天才听到对方的回应， 更不希望你的电话无法拨出。 HPC。HPC 系统最显著的特点是任务执行时间极长，一个天体物理任务的分析和计算通常耗时数周甚至数月。因此，通过水平扩展来提高系统的加速比，是 HPC 系统设计者需要关注的。 大数据。大数据任务的处理时间可能相对 HPC 系统来讲比较短，但常见的完成时间也达到了小时级，所以扩展性也是大数据系统首先要考虑的。 云计算。对于一个云计算系统而言，常见任务是虚拟主机或容器的创建、资源调整、销毁等操作，如何减少这些操作的完成时间，从而提升用户体验是设计者们要重点关注的。另 外，云计算系统本质上卖的是资源，那么降低系统本身的资源开销，也是系统设计的重中之重。 区块链。区块链的吞吐量比较低，比特币的 TPS 只有 7 次每秒，单平均一次交易的确认 就需要 10 分钟左右，因此吞吐量和完成时间通常是区块链系统设计者的首要目标。]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发（一）]]></title>
    <url>%2F2019%2F11%2F14%2F%E5%B9%B6%E5%8F%91(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[并发（一）并发编程bug源头可见性 原因：多核CPU有各自的缓存，，线程 A 操作的是 CPU-1 上的缓存，而线程 B 操作的是 CPU-2 上的缓存，很明显，这个时候线程 A 对变量 V 的操作对于线程 B 而言就不具备可见性了。 可见性是指一个线程对共享变量的修改，另外一个线程能够立刻看到。 原子性 原因：线程的切换 任务切换的时机大多数是在时间片结束的时候，我们现在基本都使用高级语言编程，高级语言里一条语句往往需要多条 CPU 指令完成。 有序性 原因：编译优化 例子：双重检查创建单例对象，如果new的时候先返回地址，另一个线程可能会引发空指针异常 123456789101112public class Singleton &#123; static Singleton instance; static Singleton getInstance()&#123; if (instance == null) &#123; synchronized(Singleton.class) &#123; if (instance == null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 32位操作系统，long的加减存在并发问题，原因：原子性，对long的加减需要多条CPU指令。 Java内存模型解决可见性和有序性的问题解决问题关键：禁用CPU缓存和禁止编译优化 Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法： volatile synchronized final 六项Happens-Before 规则 12345678910111213class VolatileExample &#123; int x = 0; volatile boolean v = false; public void writer() &#123; x = 42; v = true; &#125; public void reader() &#123; if (v == true) &#123; // 这里 x 会是多少呢？ &#125; &#125;&#125; 1.5之前可能是42，也可能是0，1.5之后是42. Happens-Before 规则含义：前面一个操作的结果对后续操作是可见的 规则： 程序的顺序性规则：按照程序顺序，前面的操作 Happens-Before 于后续的任意操作 volatile 变量规则：对一个 volatile 变量的写操作相对于后续对这个 volatile 变量的读操作可见 传递性：A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。 管程中锁的规则：管程是一种通用的同步原语，在Java 中指的就是 synchronized，synchronized 是 Java 里对管程的实现。解锁可见于后面加锁。 线程 start() 规则：主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作 线程 join() 规则：它是指主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的操作。 final关键字 final 修饰变量时，初衷是告诉编译器：这个变量生而不变，可以可劲儿优化。 加锁本质就是在锁对象的对象头中写入当前线程id，new出来只在一个地方使用的对象，其它线 程不能对它解锁，这个锁会被编译器优化掉。 互斥锁原子性问题产生的原因是线程的切换。单核cpu下可以通过禁止线程切换解决问题，但多核cpu则存在问题。 互斥： 同一时刻只有一个线程执行 。 简易的锁模型加锁–&gt;临界区–&gt;解锁 改进后的锁模型锁和锁要保护的资源是有对应关系 创建受保护资源的锁 加锁操作 临界区 解锁操作 Java提供的锁技术： synchronized 修饰代码块的时候，锁定了一个指定对象 当修饰静态方法的时候，锁定的是当前类的 Class 对象 当修饰非静态方法的时候，锁定的是当前实例对象 this 锁和受保护资源的关系受保护资源和锁之间的关联关系是 N:1 的关系，即可以一把锁保护多个资源。 保护没有关联关系的多个资源 针对没有关联关系的多个资源分别设置不同的锁，也可以用同一把锁，但性能较低 用不同的锁对受保护 资源进行精细化管理，能够提升性能。这种锁还有个名字，叫细粒度锁。 保护有关联关系的多个资源 用同一把锁来保护多个资源，也就是现实世界的“包场”，那在编程领域应该怎么“包场”呢？很简单，只要我们的锁能覆盖所有受保护资源就可以了。但同一锁在不同线程之间传递会存在问题。 用 Account.class 作为共享的锁 。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL技术内幕（一）]]></title>
    <url>%2F2019%2F10%2F30%2FMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[MySQL技术内幕（一）数据库：物理操作系统文件或其他类型文件集合 如果表格b采用MyISAM，在数据库/usr/local/mysql/data/user 中会产生3个文件： b.frm ：描述表结构文件，字段长度等 b.MYD(MYData)：数据信息文件，存储数据信息(如果采用独立表存储模式) b.MYI(MYIndex)：索引信息文件。 如果表格b采用InnoDB，在数据库/usr/local/mysql/data/user中会产生1个或者2个文件： b.frm ：描述表结构文件，字段长度等 如果采用独立表存储模式，/usr/local/mysql/data/user中还会产生b.ibd文件（存储数据信息和索引信息） 如果采用共存储模式的，数据信息和索引信息都存储在ibdata1中 数据库实例：有数据库后台进程/线程以及一个共享内存区组成，数据库实例用来操作数据库文件 MySQL设计为单进程多线程架构。 启动实例时，MySQL会读取配置文件，根据配置文件启动数据库。没有配置文件不会报错，根据默认参数，而Oracle会。 MySQL由以下几部分组成： 连接池组件 管理服务和工具组件 SQL接口组件 查询分析器组件 优化器组件 缓冲组件 插件式存储引擎 物理文件 存储引擎是基于表的。 InnoDB 存储引擎InnoDB 体系架构 内存池 缓存池：缓存各种数据，将数据库文件按页读到缓冲池，按最近最少使用算法保留缓冲池中的数据。数据库文件修改，先修改缓存池的页，再按一定频率将脏页刷新到文件。 缓存数据类型： 索引页 数据页 undo页（ https://blog.csdn.net/alexdamiao/article/details/51872477 ） 插入缓存 自适应哈希索引 锁信息 数据字典信息 重做日志缓冲池：重做日志信息 额外内存池：一些数据结构分配内存需要从该区申请 后台线程：负责刷新内存池中的数据，保证缓冲池中的内存缓存的是最近的数据。将已修改的数据文件刷新到磁盘，同时在异常情况下恢复 后台线程7个：4个IO线程，1个master线程，1个锁线程，1个错误监控线程 关键特性 插入缓冲（性能） 对于非聚集的辅助索引，数据页的存放还是按主键id的执行顺序存放。对于非聚集索引，叶子节点的插入不是顺序的。先判断插入的非聚集索引页是否在缓冲池里，如果在，直接插入。不在先放入插入缓冲区中，再按一定的频率执行插入缓冲和非聚集索引的叶子节点进行合并操作。 前提条件： 索引是辅助索引 索引不是唯一的（原因：如果唯一，又需要查找索引页的情况，出现离散读的情况，插入缓冲失去了意义） 两次写（可靠性） 内存 doublewrite buffer 物理磁盘上共享表空间 脏页刷新时，先将脏页拷贝到内存doublewrite buffer，然后每次写1mb到共享表空间，马上同步磁盘 自适应哈希 InnoDB监控对表上索引的查找，如果观察到建立哈希索引可以加速，则建立。通过缓冲池的B+树构造，按频率为页建立，不需要将整个表都建哈希索引。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库（三）]]></title>
    <url>%2F2019%2F10%2F25%2F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SQLSQL数据定义基本类型 char(n) 固定长度，字符长度不够，后面追加空格 varchar(n) 可变长度 int numeric(p,d) p个数，小数点后为d位 float(n) n为精度 基本模式定义 creat 主键 外键 完整性约束 SQL查询单关系查询多关系查询]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>DBMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java文件]]></title>
    <url>%2F2019%2F10%2F06%2Fjava%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[Java 文件路径 文件位于项目根目录下 1InputStream in = new BufferedInputStream(new FileInputStream("src/main/resources/test.properties")); 文件位于类路径下，可利用Class对象或者ClassLoader对象去在类路径下查找文件 12InputStream in = p.getClass().getResourceAsStream("/test.properties");InputStream in = p.getClass().getClassLoader().getResourceAsStream("test.properties"); 注意： Class对象的getResourceAsStream(String path)中的path可以以 / 开头，也可以不以 / 开头。若以 / 开头，表示在类路径根目录下查找，不以 / 开头，表示在当前.java文件编译后.class文件所在的目录中找 ClassLoader对象的getResourceAsStream(String path)中的path不以/开头！，表示在类路径根目录下查找]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库（二）]]></title>
    <url>%2F2019%2F10%2F05%2F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据库（二）关系数据库关系数据的结构由表的集合构成，表中的一行代表一组值之间的联系。表与关系这个概念紧密相连。 n个值之间的联系可以用n-元组表示，对应于表中的一行。 关系&lt;–&gt;表 元组&lt;–&gt;行 属性&lt;–&gt;列 域：关系每个属性允许取值的集合，域要求是原子的 空值（null） 数据库模式数据库模式：数据库逻辑设计 数据库实例：数据库数据的快照 关系模式：类似于类型定义 关系实例：类似于变量的值 码（key）超码（superkey）：这些属性的组合可以使我们在一个关系中唯一的标识一个元组。 候选码（candidatekey）：超码的最小子集 主码（primary key）：由数据库表设计者选中的，用于主要区分不同元组的候选码 主码应该选择那些值从不和极少发生变化的属性 外码（foreign key）：一个关系（r1）模式可能在他的属性中包括另一个关系（r2）的主码。r1也被称为外码依赖的参照关系，r2外码的被参照关系。 关系查询语言 过程化语言 用户指导系统对数据库进行一系列操作以计算出所需的结果 非过程化语言 用户只需要描述出所需的信息，而不用给出具体过程 关系运算]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>DBMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库（一）]]></title>
    <url>%2F2019%2F10%2F04%2F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据库（一）数据库概念文件处理系统弊端： 数据的冗余和不一致 数据访问困难 数据孤立 完整性问题（约束） 原子性问题（例如转账操作） 并发访问异常 安全性问题 数据库系统 = 数据 + 修改数据的程序 数据视图抽象视图：隐藏数据存储和维护的细节 数据抽象 物理层：详细描述底层复杂结构 逻辑层 视图层 实例和模式实例：存储在数据库信息的集合 模式：数据库的总体设计 物理模式 逻辑模式 子模式 数据模型数据模型是一种描述数据、数据联系、数据语义以及一致性约束的概念工具的集合。数据模型提供了一种描述物理层、逻辑层以及视图层数据库设计的方式。 关系模型 E-R模型 基于对象的数据模型 半结构化数据模型 数据库语言 数据操纵语言（DML） 增删改查 数据定义语言（DDL） 数据存储与定义 域约束 参照完整性 断言 授权 DDL的输出放入数据字典中，数据字典包含了元数据。 数据存储与查询数据库系统的功能部件大致可以分为存储管理器和查询处理部件 存储管理器：与操作系统文件系统交互 权限及完整性管理器：完整性约束，用户权限 事务管理器：事务的执行 文件管理器：磁盘存储与分配 缓冲区管理器：决定哪些数据从磁盘上转移到内存缓冲区中 实现的数据结构： 数据文件：数据库本身 数据字典：数据库模式，元数据：数据的数据 索引 查询处理器 DDL解释器：解释DDL语句并记录在数据字典 DML编译器：翻译成执行方案，产生低级指令 查询执行引擎：执行低级指令 事务管理 一致性 原子性 持久性 事务：数据库应用中完成单一逻辑功能的操作集合 事务管理器： 并发控制管理器 恢复管理器]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>DBMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis源码分析（一）]]></title>
    <url>%2F2019%2F10%2F02%2FMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Mybatis 源码分析（一）参考：一本小小的MyBatis源码分析书 Mybatis 入门Mybatis 是什么？ MyBatis 是一种半自动化的 Java 持久层框架（persistence framework），其通过注解或 XML的方式将对象和 SQL 关联起来。半自动是因为和 Hibernate 等一些可自动生成SQL的ORM(Object Relational Mapping)框架相比，使用MyBatis需要用户自行维护SQL。 与 JDBC 对比jdbc 缺点: 代码繁琐，冗余 拼接 SQL 可能会导致 SQL 出错 SQL 写在代码中，如果要改动 SQL，就需要到代码中进行更改 手动从 ResultSet中取出数据 用户需要自行处理受检异常 Mybatis: SqlSessionFactory 是一个工厂类，一旦被创建就应该在应用运行期间一直存在，不应该丢弃或重建。SqlSession 不是线程安全的，所以不应被多线程共享。官方推荐的使用方式是有按需创建，用完即销毁。 使用 MyBatis 无需处理受检异常 SQL 写在配置文件中，进行集中管理，利于维护。同时将 SQL 从代码中剥离，在提高代码的可读性的同时，也避免了拼接 SQL 可能会导致的错误 将查询结果映射为相应的对象 JDBC 可看做是一种基础服务，MyBatis 则是构建在基础服务之上的框架。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM（二）]]></title>
    <url>%2F2019%2F09%2F25%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[深入理解 JVM（二）编译：创建完源文件之后，程序先要被JVM中的java编译器进行编译为.class文件。java编译一个类时，若这个类所依赖的类还没有被编译，编译器会自动的先编译这个所依赖的类，然后引用；若java编译器在指定的目录下找不到该类所依赖的类的 .class文件或者 .java源文件，就会报”Can’t found sysbol”的异常错误。 编译后的字节码文件格式主要分为两部分：常量池和方法字节码。 类加载与常量常量在编译阶段会存入到调用这个常量的方法所在的类的常量池中。 本质上，调用类并没有直接引用到定义常量的类，因此并不会触发定义常量的类的初始化。 当一个常量的值并非编译期间可以确定的，那么其值就不会被放到调用类的常量池中，当这程序在运行时，会导致主动使用这个常量所在的类，显然会导致这个类的初始化。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap知识点]]></title>
    <url>%2F2019%2F09%2F19%2FHashMap%2F</url>
    <content type="text"><![CDATA[HashMapHashMap 定义HashMap是基于哈希表实现的，每一个元素是一个key-value对，其内部通过数组和单链表实现。 HashMap 工作原理HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。 put() 方法实现步骤 对Key求Hash值，然后再计算下标 如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的Hash值相同，需要放到同一个bucket中） 如果碰撞了，以链表的方式链接到后面 如果链表长度超过阀值( TREEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于6，就把红黑树转回链表 如果节点已经存在就替换旧值 如果桶（数组）满了(容量16*加载因子0.75)，就需要 resize（扩容2倍后重排） get() 方法 HashMap会使用键对象的hashcode找到bucket位置，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。 hash 函数如何计算hash函数作用：根据hashcode() 求出其对应数组下标的位置 原理： 高16bit不变，低16bit和高16bit做了一个异或 (n·1)&amp;hash jdk1.8 源码： 1234567891011static final int hash(Object key) &#123; if (key == null)&#123; return 0; &#125; int h; h=key.hashCode()；返回散列值也就是hashcode // ^ ：按位异或 // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐 //其中n是数组的长度，即Map的数组部分初始化长度 return (n-1)&amp;(h ^ (h &gt;&gt;&gt; 16));&#125; 红黑树红黑树的性质 每个节点非红即黑 根节点总是黑色的 如果节点是红色的，则它的子节点必须是黑色的（反之不一定） 每个叶子节点都是黑色的空节点（NIL节点） 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度） 为什么选择使用红黑树二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。 HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。这个值只可能在两个地方，一个是原下标的位置，另一种是在下标为&lt;原下标+原容量&gt;的位置。 解决冲突其他办法 开放定址法 线性探查法 二次探查法 双重散列法 HashTable 数组 + 链表方式存储 默认容量：11(质数为宜) 索引计算 : （key.hashCode() &amp; 0x7FFFFFFF）% table.length 若在链表中找到了，则替换旧值，若未找到则继续 当总元素个数超过容量*加载因子时，扩容为原来 2 倍并重新散列。 将新元素加到链表头部 对修改 Hashtable 内部共享数据的方法添加了 synchronized，保证线程安全。 HashMap 与 HashTable 的区别 Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类。但二者都实现了Map接口。 HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey。Hashtable则保留了contains，containsValue和containsKey三个方法，其中contains和containsValue功能相同。 默认容量不同，扩容不同。计算索引方式不同。 线程安全性，HashTable 安全 效率不同 HashTable 要慢因为加锁 hashmap 键值可以设置为空值，hashtable 不可以。hashmap 将null存到table[0]中去了。 ConcurrentHashMap 原理CocurrentHashMap 与 Hashtable 加锁方式对比Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。它们都可以用于多线程的环境，但是当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。因为ConcurrentHashMap引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需要等到迭代完成才能访问map。简而言之，在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM（一）]]></title>
    <url>%2F2019%2F08%2F30%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[深入理解 JVM课程参考：http://www.iprogramming.cn 类加载Java 中类型的加载、连接和初始化过程都是在程序运行期间完成。 类型：类本身而不是实例化的对象。 加载：类的class文件从磁盘加载到内存中。 将.class文件中的二进制数据读入到内存中，放入运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象，用来封装在方法区内的数据结构。 连接：将类与类之间的关系确定好，检验字节码文件。 验证：类的正确性。 准备：类的静态变量分配内存，初始化为默认值。 解析：类中符号引用转为直接引用。 初始化：类的静态变量赋予正确的初始值，首次主动使用。 类加载器作用：将类加载到内存。 类的使用与卸载 使用 卸载 类的使用方式 主动使用 创建类的实例 访问某个类或接口静态变量或赋值 调用类的静态方法 反射 初始化一个类的子类 启动类的类 动态语言的支持 被动使用 不会导致类的初始化 1234567891011121314151617181920public class MyTest1 &#123; public static void main(String[] args) &#123; System.out.println(Child.str1); &#125;&#125;class Parent&#123; static String str1 = "123"; static &#123; System.out.println("Parent static block"); &#125;&#125;class Child extends Parent&#123; static String str2 = "234"; static &#123; System.out.println("child static block"); &#125;&#125; 结果 12Parent static block123 分析 对于静态字段来说，只有直接定义了该字段的类才会被初始化 1234567891011121314151617181920public class MyTest1 &#123; public static void main(String[] args) &#123; System.out.println(Child.str2); &#125;&#125;class Parent&#123; static String str1 = "123"; static &#123; System.out.println("Parent static block"); &#125;&#125;class Child extends Parent&#123; static String str2 = "234"; static &#123; System.out.println("child static block"); &#125;&#125; 结果 123Parent static blockchild static block234 分析 当一个类初始化时，要求其父类全部初始化完毕。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Java多线程操作（一）]]></title>
    <url>%2F2019%2F08%2F24%2Fthread%2F</url>
    <content type="text"><![CDATA[线程线程基本概念线程是 CPU 调度的基本单位，进程是 CPU 分配资源的基本单位。 Java 中的多线程Java 中创建多线程的两种方式 通过继承Thread类，并重写run方法创建线程 1234567class MyThread extends Thread&#123; @Override public void run() &#123; System.out.println("hello thread!"); &#125;&#125; 通过实现Runnable接口，并传递给Thread类，创建线程。 1234567class MyThread2 implements Runnable&#123; @Override public void run() &#123; System.out.println("hello thread2!"); &#125;&#125; Java 中的线程生命周期 线程新建状态 使用 Java 创建线程的两种方法，创建一个新的线程。 线程就绪状态 通过调用新线程的start()方法使之进入就绪状态 运行中的线程失去CPU运行时间进入就绪状态 阻塞状态的线程处理完阻塞进入就绪状态 线程运行状态 就绪状态的线程一旦获得CPU便进入运行状态 线程阻塞状态 使用线程的sleep()方法 运行状态中的线程执行wait()方法 线程死亡状态 线程生命周期结束 Java 线程同步Java 多个线程同时抢夺资源，造成冲突问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Bank&#123; int i = 0; void add()&#123; i++; &#125; int getI()&#123; return i; &#125;&#125;class MyThread extends Thread&#123; Bank bank; MyThread(Bank b)&#123; bank = b; &#125; @Override public void run() &#123; for(int x = 0; x &lt; 10; x++) &#123; bank.add(); System.out.println(Thread.currentThread().getName() + " value: " +bank.getI()); &#125; &#125; &#125;public class Demo &#123; public static void main(String[] args) &#123; Bank bank = new Bank(); MyThread myThread = new MyThread(bank); myThread.start(); MyThread myThread2 = new MyThread(bank); myThread2.start(); MyThread myThread3 = new MyThread(bank); myThread3.start(); &#125;&#125; 运行结果： 12345Thread-0 value: 2Thread-0 value: 4Thread-2 value: 3Thread-1 value: 2Thread-2 value: 6 同步方法 使用synchronized关键字 由于 Java 的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。 123public synchronized void add()&#123; i++; &#125; 同步代码块 有synchronized关键字修饰的语句块，被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。必须使用同一个锁。 12345public void add()&#123; synchronized (this) &#123; i++; &#125; &#125; 使用特殊域变量(volatile)实现线程同步 volatile具有synchronized关键字的“可见性”，但是没有synchronized关键字的“并发正确性”，也就是说不保证线程执行的有序性。 volatile变量对于每次使用，线程都能得到当前volatile变量的最新值。但是volatile变量并不保证并发的正确性。 1volatile int i = 0; https://www.hollischuang.com/archives/2648 使用重入锁（Lock）实现线程同步 123ReentrantLock() : 创建一个ReentrantLock实例 lock() : 获得锁 unlock() : 释放锁 123456789class Bank&#123; volatile int i = 0; private Lock lock = new ReentrantLock(); void add()&#123; lock.lock(); i++; lock.unlock(); &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
